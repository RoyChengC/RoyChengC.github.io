<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F02%2F18%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件设计与体系结构复习提纲]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[第一章 面向对象设计 面向对象设计原则：单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、合成复用原则、迪米特法则 单个类关注：抽象、封装、信息隐藏；多个合作类关注：松耦合、开闭、里氏、依赖倒置、契约式设计 可读性（封装、抽象、信息隐藏、关注点分离、单一职责）、正确性（LSP、契约式设计）、可扩展性（接口隔离、松耦合、LSP、开闭、依赖倒置） 开闭原则是面向对象设计的核心，带来可重用性和可维护性，关键是抽象 里氏替换原则，与继承相关；若能用基类，则能用子类 依赖倒置原则：高层模块不应该依赖低层模块，应该依赖抽象；可以创建可重用框架；针对接口编程而不是针对实现编程 接口隔离原则：处理胖接口（接口不内聚），避免接口污染（为借口添加了不必要的职责），将大接口细化成小接口 单一职责原则：关注点分离，实现高内聚低耦合，一个类应该有且仅有一个职责 契约式设计 第二章 软件架构 软件架构涉及设计模式和架构模式 架构降低复杂度，规定系统的结构和实施流程 系统架构包括：分解成组件、分配组件、组件的相互作用、架构的静态和动态的功能 系统架构可以包含多个架构模式 架构模式可以包含多个设计模式 系统分为多种类型：硬实时系统、软实时系统、非实时系统 系统中的分析任务：明确系统的目的和主要任务、应用流程、接口 系统中的结构设计任务：整体硬件架构 软件架构的原型：水平原型、垂直原型、可行性原型 第三章 软件设计的模式 模式促进软件开发的发展，模式是一个抽象类或接口的符号 模式的主要目标：提高架构的灵活性和可扩展性 模式提高了系统的扩展性、降低了系统的性能、增加了架构的复杂度 设计模式描述的是细致的模式，架构模式是粗略的模式 架构模式描述软件系统里的基本的结构组织或纲要 第四章 设计模式–结构型模式 设计模式：描述复杂软件系统中普遍存在，重复出现的结构、模式、套路，用来解决在一定的场景下，具有一般性的设计问题 模式的核心思想：增加抽象层，分离出变化部分 设计模式分类（按目的）：创建型、结构型、行为型 设计模式分类（按范围）：类模式、对象模式 设计模式解决设计问题：寻找合适的对象、决定对象的粒度、指定对象的接口、描述对象的实现、运用复用机制、运行时刻和编译时刻的结构、设计应支持变化 结构型模式：如何将类或对象结合在一起形成更大的结构，可分为类结构型模式（类之间的静态继承）和对象结构型模式（对象在运行时可以发生变化） 适配器模式：将一个类的接口转换成客户期望的另一个接口 类适配器：用一个具体的adapter类对adaptee和target进行匹配，adapter类多重继承adaptee和target类 对象适配器：允许一个Adapter与多个Adaptee同时工作，即Adaptee本身以及它的所有子类（如果有子类的话）同时工作。Adapter可以一次给所有的Adaptee添加功能 效果：适配器模式将目标类和适配者类解耦，增加了类的透明性和复用性，灵活性和扩展性好。 桥梁模式（对象结构型模式）：将抽象部分与实现部分分离，使它可以独立的变化 效果： 桥梁模式分离接口和实现部分，提高可扩充性； 实现细节对用户透明； 将强关联改成弱关联； 继承关系是强关联，聚合关系是弱关联 装饰模式（对象结构型模式）：以对客户透明的方式动态给对象添加额外职责，不是通过继承，而是通过组合实现 注意：装饰模式应该遵循里氏代换原则，装饰类必须覆写所有继承的方法 效果：比静态继承更加灵活，避免在层次结构高层的类有太多的特征 装饰模式 vs 适配器模式： 装饰模式增强功能，不改变接口； 适配器模式改变接口，不改变功能 外观模式（对象结构型模式）：设计原则为迪米特法则；提供了一个统一的接口，用来访问子系统中的一群接口；定义一个高层接口，使子系统更加容易使用 效果： 减少客户端的对象数目； 实现了子系统和客户之间松耦合； 不限制客户应用子系统类； 子系统中类的功能收到外观的限制 组合模式（对象结构型模式）：把对象归集成一个树形结构，若是简单的没有组合的基本单位就是叶对象，若节点互相聚集在一起就是组合对象；在组合模式下，树形结构中的节点在工作时无论是单一的还是组合的都会同样处理；通过Component接口操纵组合部件的对象 效果：简化客户代码，一致使用组合对象和单个对象；容易增加新类型的组件； 注意，与装饰模式的对比： 一定程度上，装饰模式是组合模式的一个特例； 装饰对象只能聚集一个对象，动态构建功能； 组合模式把对象组装为一个层次结构 代理模式（对象结构型模式）：为其他对象提供一种代理以控制对这个对象的访问，用代理来替代被访问的实体 类似的模式：代理模式、装饰模式、适配器模式 区别： 代理使用实际对象相同接口，适配器转换了接口 装饰模式为了动态添加功能，代理模式也可以 *享元模式（对象结构型模式）：运用共享技术有效地支持大量细粒度的对象，避免大量拥有相同内容的小类的开销，使大家共享一个对象 第四章 设计模式–行为模式 行为模式是对不同对象之间划分责任和算法的抽象化，它不仅描述类和对象的结构，而且重点关注它们之间的交互和通信 行为型模式分为类行为型模式和对象行为型模式 类行为型模式使用继承机制在类之间分派行为，通过多态等方式分配父类和子类的职责 对象行为型模式使用对象复合而不是继承分配行为，通过对象关联等方式来分配多个类的职责 合成复用原则 模板方法模式（类行为型模式）： 实现父类和子类对象之间职责的划分； 使用继承机制使得父类和子类之间达到分工合作的目的； 基类中确定算法框架，子类实现具体工作； 子类不需要改变算法结构即可重定义算法的某些步骤； 将相同的代码放在父类中，不同的方法放在不同的子类中 效果：模板方法是一种代码复用技术，导致一种反向的控制结构（依赖倒置原则） 命令模式（对象行为型模式）：将请求封装成对象，用不同请求对客户参数化；请求发送者和请求接收者解耦 效果：命令可以被扩展，满足ocp原则 观察者模式（对象行为型模式）： 定义对象间的一种一对多的依赖关系； 当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新 一个对象可以被多个观察者观察，即被观察者和观察者是一对多关系 效果： 目标和观察者之间松耦合，可以各自独立改变； 允许独立改变目标和观察者； 高内聚低耦合； 一个目标被大量订阅，广播通知时会有效率问题 策略模式（对象行为型模式）：定义一系列算法，并进行封装，使其可以相互替换；根据环境条件的不同，选择不同的策略来完成该项任务 strategy类层次为context定义了一系列可供重用的算法，环境类依赖接口，不依赖具体实现 策略模式 vs 装饰模式、模板方法模式： 策略模式实现相同功能，更换策略不改变总体功能； 装饰模式动态增加功能 模板方法父类静态定义算法基本框架，子类只允许改变算法中的步骤 中介者模式（对象行为型模式）：用一个中介对象来封装一系列的对象交互；中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立改变他们之间的交互；为了减少对象两两之间复杂的引用关系 效果： 减少了子类生成；各个同事松耦合； 简化了对象间关联； 控制集中化； 中介者难复用 状态模式（对象行为型模式）：允许一个对象在其内部状态改变时改变他的行为；一个对象与外部事件交互，内部状态改变，其行为也随之变化 适用性：对象行为取决于其状态；一个操作中含有庞大的多分支条件语句 效果： 使用状态模式，动作完成后可以自动切换到下一个状态，客户无需知道具体切换逻辑。每个ConcreteState实例只需要知道本状态后可能过渡到哪些状态及相应条件； 实现了与状态相关的行为的局部化； 使用状态模式将状态的切换逻辑放到state的派生类中，动作的实现供派生类进行调用，实现逻辑和动作的解耦 访问者模式（对象行为型模式）： 表示一个作用于某个对象结构中的各元素的操作； 可在不改变这些对象本身的情况下，定义作用于这些对象的新操作； 封装一些施加于某种数据结构元素之上的操作 为不同类型的元素提供了多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式 效果： 不改变具体元素类，就可以增加新操作，主要是通过元素类的accept方法接受一个visitor对象来实现的 不易频繁增加元素类，每增加一个元素类，就要在visitor接口中写一个针对该元素的方法，还要修改visitor子类 迭代器模式（对象行为型模式）：提供一种可顺序访问聚合对象中各个元素的方法，但不暴露该对象内部表示；提供外部对象使用的迭代器，对聚合访问和遍历 效果： 支持以不同的方式遍历一个集合； 迭代器简化了聚集的接口； 在同一个聚集上可以有多个遍历； 职责链模式（对象行为型模式）： 避免请求的发送者和接收者之间的耦合关系； 多个对象都有机会处理一个请求； 对象连成一条链，沿链传递该请求，直到有对象处理 客户无需关心请求的处理细节和请求的传递，只需将请求发送到链上即可 效果： 降低耦合度； 增强了给对象分配职责的灵活性； 不保证被接受 第四章 设计模式–创建型模式 创建型模式关注的是对象的创建，将创建对象的过程进行抽象； 作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑 工厂模式：专门负责实例化有共同父类（接口）的类的实例；工厂模式可以动态决定实例化哪一个子类对象，不必事先知道要实例化哪个类 简单工厂模式： 在该模式中可以根据参数的不同返回不同类的实例； 专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类 效果： 将对象的创建和对象本身业务处理分离可以降低系统的耦合度； 工厂类的职责过重，增加新的产品要修改工厂类的判断逻辑； 当你需要什么，只需要传入一个正确的参数就可以获取你想要的对象，而无需知道创建细节 总结： 将具体的对象生成，移植到服务端代码的一个对象生成工厂中； 当有需求要增加新的子类对象时，客户端的代码不再需要修改，只需修改服务端代码 工厂模式： 解决了简单工厂模式违反开闭原则问题，增加工厂类的动态性； 定义一个用户创建对象的接口，让子类决定实例化哪一个类； 效果：为子类提供挂钩；连接平行的类层次 总结： 工厂模式中，核心的工厂类不再负责所有产品的创建，而是将具体的创建工作交给子类去做； 增加新产品类时无需修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性； 增加新产品时需要增加新的工厂，导致系统类的个数成对增加，一定程度上增加了系统的复杂性 抽象工厂模式： 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类； 应用于系统独立于其产品创建、组合和表示时； 当系统提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的产品时 效果： 隔离了具体类的生成，使得客户并不需要知道什么被创建，更换一个具体工厂就变得相对容易； 改变具体工厂的实例，就可以在某种程度上改变软件系统的行为； 高内聚低耦合 单例模式（对象创建型模式）：保证一个类仅有一个实例，提供一个全局访问点 效果： 严格控制客户怎样及何时访问它； 对全局变量的一种改进，避免污染名空间； 允许对操作和表示的精化 生成器模式（对象创建型模式）： 逐步构造对象，使得对象的创建更具弹性； 将一个包含多个组件对象的创建分成若干个步骤，并将这些步骤封装在Builder接口中 效果： 使产品的内部表象可以独立变化； 每一个builder相对独立，与其他builder无关； 可对构造过程更加精细控制； 将构建代码和表示代码分开 第五章 架构模式 多视图方法是软件架构归档的方法，更是指导我们进行架构设计的思维方法 软件架构视图：对于从某一视角或某一点上看到的系统所做的简化描述，描述中涵盖了系统的某一特定方面，而省略了于此方面无关的实体 4+1视图： 逻辑架构：关注功能，着重考虑功能需求 开发架构：关注程序包，着重考虑开发期质量属性 运行架构：关注进程、线程、对象等运行时概念及相关的并发同步通信等问题，着重考虑运行期质量属性 物理架构：关注软件系统最终如何安装或部署到物理机器 数据架构：关注持久化数据的存储方案 逻辑视图：关注用户可见的功能，还包括为实现用户功能而必须提供的辅助功能模块 开发视图：关注程序包，不仅包括编写的源程序，还有可以直接使用的第三方SDK和现成框架、类库、中间件 运行视图：关注运行时单元的交互问题 物理视图：重视目标程序的静态位置问题 场景视图：可理解性 分层架构模式： 系统将划分为一个层次结构； 各层之间的关系是客户/服务器； 每一层都具有高度内聚性； 有助于将复杂系统划分成独立模块； 每层都向上层提供服务，同时又利用了下层的逻辑功能 上层通过下层提供的接口来使用下层的功能 优点：减少依赖程度、支持扩展、支持重用 缺点：层次划分不易、不一定能够层次化、系统性能下降、难以调试 管道过滤器架构模式： 过滤器读取数据，加工转换，变成输出数据； 过滤器间通过管道连接； 每个过滤器是独立的实体； 管道传输和缓存数据 优点：简单性；重用性；系统易维护和扩展；并发性 缺点：过滤器对输入数据批量转换；不适合设计交互式应用系统；兼容性弱；降低系统效率 插件架构模式：扩展点用接口表示，插件用于实现这些接口并安装；应用在没有添加扩展时也能正常使用 优点： 每个插件有自己的职责范围； 便于第三方扩展； 保持系统的精简； 支持多版本同时运行； 插件的独立测试 缺点： 初始过程消耗高； 执行过程中管理开销不断提高； 插件和接口有依赖关系 中介模式（分布式系统架构模式）：服务器组件提供一个或多个服务；客户组件需要服务器组件的一个或多个服务 优点：客户无需知道服务器的物理地址；通过服务器的逻辑名称实现了隐藏 缺点：容错性差；间接调用增加了调用的通信开销；中介可能形成拼接 对比： 中介者模式同事通过mediator通信，处在同一系统。发送和接受1：n关系； 中介模式负责分布式系统中确定接受组件位置，发送和接受1：1 SOA架构模式： 把一个业务流程直接构建为一个计算机系统； 应用场景被分配给设计的组件，易于修改； 一个应用场景的目标就是实现一个服务； 一个业务流程会使用这个服务 优点： 根据业务流程构成服务组件； 分解服务组件和基本服务组件，减小系统复杂性； 可复用； 接口不变，服务的实现可动态转换 缺点： 过于细分服务组成复杂的结构； 多个层次通信增加额外开销 MVC模式： 模型（核心功能）封装系统数据和对数据的加工； 视图把数据展示给用户，含有模型要展示的数据； 控制器负责接收用户的输入，对输入的内容进行解释 优点： 模型类和用户界面分别设计； 修改界面无需更改模型；模型单独测试； 同一应用设计不同用户界面 缺点： 经常更新影响系统性能； 细分多个类增加实现开销]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件设计与体系结构</tag>
        <tag>复习提纲</tag>
      </tags>
  </entry>
</search>
