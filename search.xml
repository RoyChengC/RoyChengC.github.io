<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-23 Merge K Sorted Lists]]></title>
    <url>%2F2019%2F03%2F24%2Fleetcode-23-Merge-K-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[23. Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 合并k个有序链表，返回一个排好序的链表。 Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路： 把k个链表中的元素一一取出，并将它们放入一个vector中，之后对vector进行排序。最后将排序好的vector转化成链表即可。 123456789101112131415161718192021222324class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; vector&lt;int&gt; vec; int n = lists.size(); for (int i = 0; i &lt; n; ++i) &#123; ListNode* node = lists[i]; while (node != NULL) &#123; vec.push_back(node-&gt;val); node = node-&gt;next; &#125; &#125; sort(vec.begin(), vec.end()); ListNode head(0); ListNode* result = &amp;head; for (int i = 0; i &lt; (int)vec.size(); ++i) &#123; ListNode* temp = new ListNode(vec[i]); result-&gt;next = temp; result = result-&gt;next; &#125; return head.next; &#125;&#125;; 进阶： 以下出自http://www.cnblogs.com/grandyang/p/4606710.html 之前有一道合并两个有序链表链表的题目（21. Merge Two Sorted Lists），我们同样可以通过两两合并来解决这道问题，但是这样做时间复杂度太高。 我们可以通过最小堆解决这个问题。首先把k个链表的首元素都加入最小堆中，它们会自动排好序。然后我们每次取出最小的那个元素加入我们最终结果的链表中，然后把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆中没有元素了，此时k个链表也合并为了一个链表，返回首节点即可。 1234567891011121314151617181920class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto cmp = [](ListNode*&amp; a, ListNode*&amp; b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp) &gt; q(cmp); for (auto node : lists) &#123; if (node) q.push(node); &#125; ListNode *dummy = new ListNode(-1), *cur = dummy; while (!q.empty()) &#123; auto t = q.top(); q.pop(); cur-&gt;next = t; cur = cur-&gt;next; if (cur-&gt;next) q.push(cur-&gt;next); &#125; return dummy-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>排序</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件构造复习提纲]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[Part 1软件构造是编码加调试，包括部分的详细设计和单元测试、集成测试以及其他活动，即软件构造不等于编码实现 测试是为了发现错误，调试是为了确定错误的位置并修改错误 SOA–service oriented architecture 面向服务的架构模型：一个服务有多个消费者，每个消费者都对服务有自己特定的期望，服务供应商应该演化以满足期望的变化 CDC–consumer driven contract 消费者驱动契约：解决SOA问题 支持契约式编程的语言Eiffel 契约式编程：根据事先给定的前置条件、后置条件和不变式来实现代码 隐喻并非是简单的用一个名词对软件事务进行类比，还包含了对类比的事物之间的体验和分析 隐喻更像启示，而不是算法，帮助开发人员加深对编程的理解 软件构造的前期准备工作的目标：降低风险，避免糟糕的需求分析和项目计划 软件项目类型：性命攸关（序列式开发）、使命攸关、一般商业系统（迭代式开发） 序列式开发：使用瀑布模型、适用于需求稳定的情况，设计简单，后期更改代价高 迭代式开发：整个工作被组织成一系列迭代过程，适用于需求经常变更的情况，设计复杂，后期更改代价低 RUP(Rational Unified Process)：统一软件开发过程 开始构建的先决条件：明确问题定义（整个开发的基础）、明确需求规约、明确的架构设计（软件设计的高层部分） 需求定义：详细规定了软件系统应该做什么 软件架构的组成：程序组织、主要的类、数据设计、业务规则、UI设计、安全性、错误处理、容错性、变更策略、国际化/本地化 软件架构的两个要素：元件划分、设计决定 80/20原则 前期准备：10-20%的工作量、20-30%的时间 Part 2软件的首要技术使命：管理复杂度 理想的设计特征：最大程度降低复杂化、易于维护、可扩展性、可复用性、可移植性、高扇入低扇出、松耦合 设计的层次：软件系统、分解成子系统和包、分解成包中的类、分解成类中的子程序和数据、子程序内部 子程序：具有一定功能的，可以调用的函数或过程 模块：数据及作用于数据的子程序的集合 为什么要模块化：提高维护性 模块独立程度的衡量标准：内聚性、耦合性 内聚性：一个模块/子程序内各种操作之间互相联系的紧密程度–每个模块/子程序只做一个工作 耦合性：软件结构内各个模块的关联程度 内聚性：功能内聚（最高）、顺序内聚（较高）、通讯内聚（中）、临时内聚（中）、过程内聚、偶然内聚（低）、时间内聚（低）、逻辑内聚（低） 耦合性：无任何连接、数据耦合、控制耦合、公共环境的耦合、内容耦合 过程内聚和顺序内聚的区别：使用的数据是不同的/使用的数据是相同的 模块的封装部分是内部信息，公开部分是接口和公开信息 常见需要隐含的信息：容易被改动的区域、复杂的数据、复杂的逻辑 模块包括：数据、数据类型、数据操作、公共和局部操作 ADT：一组数据和对应这组数据的操作的集合 类：一组数据和子程序的集合 ADT + 封装、继承、多态 = 类，而ADT是弱封装 类接口提供了类公开的操作，普通接口只提供了操作的声明 类接口需要一致的抽象、良好的封装 继承：一个类是另一个类的特化–is a 关系 包含：一个类中拥有另一个类–has a 关系 包含通过成员数据来实现，不得已的情况下可以用private的继承实现has a关系 用public继承实现is a关系 LSP原则使得继承降低复杂度 接口继承：子接口是父接口的扩充或细化 实现继承：派生类同时继承函数的接口和实现部分 慎用 实现继承会带来更多的耦合问题 继承关系容易产生基类和子类的强耦合 Part 3墨菲法则：所有有可能出错的事物终将出错–所有的程序都有缺陷 防御式编程的目标：提高代码质量、提高代码可读性、使程序运行可预测、保护程序免受非法数据的破坏 断言：表示程序运行到此处需要满足的条件，能使程序运行时自检 断言 = 布尔表达式 + 断言不成立输出的信息 错误处理代码：检查预期发生的状况，检查有害的输入数据 断言：检查绝不该发生的情况，检查是否有bug 避免把需要运行的代码放到断言中；一般先使用断言，在使用错误处理代码；用断言注释并验证前条件和后条件 错误处理技术：返回中立值、返回下一个正确的值、返回上一个正确的值、输出错误信息、关闭程序。。。 异常：把代码中的错误或异常事件传递给调用方代码的一种特殊手段 异常结构：子程序使用throw抛出异常对象，再传递给上层；try-catch捕获异常 异常处理机制涉及的要素：异常对象、异常对象的抛出、异常的捕获 finally：关闭流、关闭连接、释放销毁资源 C++提供RAII机制取代finally RAII（Resource Acquisition is Initialization）：资源获取即初始化，资源从析构函数释放 finally针对特定应用，RAII针对资源本身 隔离部分是脏数据，应使用错误处理技术；隔离区内部的是干净数据，应使用断言机制 去除检查细微错误，使程序硬性崩溃的代码 保留检查重大错误，使程序稳妥崩溃的代码，记录错误信息的代码 Part 4变量定义和声明的规则：关闭隐式声明，声明所有变量，遵循命名规则 变量初始化原则：在声明时初始化，在靠近变量第一次使用的时候声明和初始化，需要的情况下使用final和const，注意累加器和计数器，使用构造函数初始化 变量作用域：使变量引用局部化，缩短变量的生存时间 减小跨度和攻击窗口 以上增强可读性和可维护性 变量与数值的绑定时间越晚越好 绑定时间的种类：编码时，编译时，加载时，对象实例化时，即时 数据类型与控制结构的关系：序列型数据–顺序，选择型数据–if/case，迭代型数据–循环 Part 5语句类型：顺序型语句，条件语句，控制循环语句，特殊控制结构，表驱动法 条件语句使用原则：首先写代码的正常路劲，在处理其他情况，把异常代码路径当作防卫语句处理；把正常情况放在if后面，if子句应该有意义；用布尔函数简化判断；小心使用switch 循环的种类：计数循环，连续求值的循环，无限循环，迭代器循环 带退出的循环：退出条件应该放在一处，用注释阐明操作意图 把循环看作黑盒子 进入循环：尽量在一个地方进入循环，在循环之前初始化，如何选择while/for循环 循环体：明确循环体的部分（用大括号包围），避免空循环，注意循环内务操作应放在开始或结尾 循环内务操作：控制循环的变量，如 i++ 退出循环：明确退出循环的条件，避免使用最终的循环下标取值 不常见的控制结构/特殊的控制结构：子程序中多处返回，goto，递归 多处返回的原则：增强可读性，用防卫子句简化逻辑 递归：确保递归终止条件，用安全计数器防止无限递归，避免循环递归 goto：goto增加复杂度，降低程序性能，格式难以安排 / 可减少重复代码，加快运行速度；不能随意使用 表驱动法：直接访问，索引访问，阶梯访问 Part 6协同构建包括：代码集体所有，代码评审，结对编程 协同构建的目的是改善代码质量 代码集体所有的好处：提高代码质量，人员离开项目的影响减少，改错的周期减少 结对编程：增加10-25%成本，节省45%时间 评审包括：检视/审查/详查（Inspection，正式的）、走查（Walkthrough，非正式的）、技术评审（Technical Review，正式的） 评审步骤：计划、概述（可选）、准备、详查会议、第三个小时的会议（可选）、返工、跟进 开发者测试：单元测试、组件测试、集成测试、回归测试、系统测试 测试又分为黑盒和白盒测试 开发者测试占整个项目时间的8-25% 传统的开发者测试是单元和集成测试 重构的类型：数据级的重构、语句级的重构、子程序级的重构、类实现的重构、类接口的重构、系统级的重构 重构：在不改变软件的外部行为的条件下，对其内部结构进行改变，使之更容易理解和修改 安全的重构：保存原始代码、设置检查点、减缓重构的步伐（每次重构小部分）。。。 重构策略：关注高复杂度的模块、关注易错的模块、修改缺陷时重构。。。 代码调优（code tuning）：修改正确的代码使其更有效地运行；调优一般是影响一个类或几行代码的小规模更改 注意代码调优和重构的区别 管理构建的关键问题—-如何鼓励良好的编程实践 配置管理：系统化地定义项目的工作和处理变化，使项目一直保持其完整性的实践活动 Part 7图灵机的思想：用机器来模拟人们用纸笔进行数学运算的过程（在纸上写下或擦除某种符号，把注意力从纸的一个位置移动到另一个位置） 图灵机的原理/构造：无限长带有小格子的纸带，读写头，控制规则表，状态寄存器 七元组：{ Q，Σ，Γ，δ，q0, qaccept, qreject }，Q相当于状态寄存器，Σ相当于无限长的纸带，δ相当于控制规则表，q0是起始状态，qaccept是接受状态，qreject是拒绝状态 形式文法：G = { V, T, S, P }，V相当于Γ，S相当于q0，P相当于δ 基于代数和逻辑的方法：larch，clear，obj，cafeobj 基于模型的方法：z，b，vdm，object-z 敏捷开发模式 TDD(Test Driven Development) 测试驱动开发 TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。 BDD(Behavior Driven Development) 行为驱动开发 行为驱动开发是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。主要是从用户的需求出发，强调系统行为。 ATDD(Acceptance Test Driven Development) 验收测试驱动开发 在准备实施一个功能或特性之前，团队首先需要定义出期望的质量标准和验收细则，以明确且达成共识的验收测试计划（包含一系列测试场景）来驱动开发人员的功能开发实现和测试人员的测试脚本开发。 DDD(Domain Driven Design) 领域驱动开发 领域驱动设计是对面向对象的的分析和设计（OOAD，Object Orient Analysis Design）的一个补充，对技术框架进行了分层规划，同时对每个类进行了策略和类型划分。 FDD(Feature Driven Development) 特征驱动开发 它强调特性驱动，快速迭代，即能保证快速开发，又能保证适当文档和质量，非常适合中小型团队开发管理。它提出的每个功能开发时间不超过两周，为每个用例限定了粒度，具有良好可执行性，也可以对项目的开发进程进行精确及时地监控。 用户故事 用户故事是描述对用户有价值的功能，好的用户故事应该包括角色、功能和商业价值三个要素。用户故事通常的格式为：作为一个&lt;角色&gt;, 我想要&lt;功能&gt;, 以便于&lt;商业价值&gt;。 一个好的用户故事包括三个要素： ​ 角色：谁要使用这个功能。 ​ 功能：需要完成什么样的功能。 ​ 商业价值：为什么需要这个功能，这个功能带来什么样的价值。 Scrum迭代式增量软件开发过程、XP极限编程 Scrum偏重于过程，XP则偏重于实践 Scrum开发流程的三大角色 产品负责人(Product Owner)：主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。 流程管理员(Scrum Master)：主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。 开发团队(Scrum Team)：主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。 Scrum开发模型 产品需求列表 Product Backlog：由Product Owner负责，提供用户故事 迭代 Sprint：一次Sprint Backlog完成，表示一次Sprint完成 迭代计划会议 Sprint Planning Meeting：形成Sprint Backlog 迭代任务列表 Sprint Backlog：由Scrum Team完成 每日站立会议 Daily Scrum Meeting 迭代燃尽图 Sprint Burn Down 迭代演示会议 Sprint Review Meeting：Sprint完成后的评审会议，演示软件产品 迭代回顾会议 Sprint Retrospective Meeting：总结会议，总结讨论需要改进的地方，放入下一轮Sprint的产品需求中 XP极限编程 eXtreme Programming 它强调程序设计团队与业务专家之间的紧密协作、面对面的沟通（比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好的适应需求变化的代码编写和团队组织方法，更注重软件开发中人的作用。 XP中包含的概念：持续集成CI(Continuous Integration)、结对编程]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件构造</tag>
        <tag>复习提纲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计与体系结构复习提纲]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[第一章 面向对象设计 面向对象设计原则：单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、合成复用原则、迪米特法则 单个类关注：抽象、封装、信息隐藏；多个合作类关注：松耦合、开闭、里氏、依赖倒置、契约式设计 可读性（封装、抽象、信息隐藏、关注点分离、单一职责）、正确性（LSP、契约式设计）、可扩展性（接口隔离、松耦合、LSP、开闭、依赖倒置） 开闭原则是面向对象设计的核心，带来可重用性和可维护性，关键是抽象 里氏替换原则，与继承相关；若能用基类，则能用子类 依赖倒置原则：高层模块不应该依赖低层模块，应该依赖抽象；可以创建可重用框架；针对接口编程而不是针对实现编程 接口隔离原则：处理胖接口（接口不内聚），避免接口污染（为借口添加了不必要的职责），将大接口细化成小接口 单一职责原则：关注点分离，实现高内聚低耦合，一个类应该有且仅有一个职责 契约式设计 第二章 软件架构 软件架构涉及设计模式和架构模式 架构降低复杂度，规定系统的结构和实施流程 系统架构包括：分解成组件、分配组件、组件的相互作用、架构的静态和动态的功能 系统架构可以包含多个架构模式 架构模式可以包含多个设计模式 系统分为多种类型：硬实时系统、软实时系统、非实时系统 系统中的分析任务：明确系统的目的和主要任务、应用流程、接口 系统中的结构设计任务：整体硬件架构 软件架构的原型：水平原型、垂直原型、可行性原型 第三章 软件设计的模式 模式促进软件开发的发展，模式是一个抽象类或接口的符号 模式的主要目标：提高架构的灵活性和可扩展性 模式提高了系统的扩展性、降低了系统的性能、增加了架构的复杂度 设计模式描述的是细致的模式，架构模式是粗略的模式 架构模式描述软件系统里的基本的结构组织或纲要 第四章 设计模式–结构型模式 设计模式：描述复杂软件系统中普遍存在，重复出现的结构、模式、套路，用来解决在一定的场景下，具有一般性的设计问题 模式的核心思想：增加抽象层，分离出变化部分 设计模式分类（按目的）：创建型、结构型、行为型 设计模式分类（按范围）：类模式、对象模式 设计模式解决设计问题：寻找合适的对象、决定对象的粒度、指定对象的接口、描述对象的实现、运用复用机制、运行时刻和编译时刻的结构、设计应支持变化 结构型模式：如何将类或对象结合在一起形成更大的结构，可分为类结构型模式（类之间的静态继承）和对象结构型模式（对象在运行时可以发生变化） 适配器模式：将一个类的接口转换成客户期望的另一个接口 类适配器：用一个具体的adapter类对adaptee和target进行匹配，adapter类多重继承adaptee和target类 对象适配器：允许一个Adapter与多个Adaptee同时工作，即Adaptee本身以及它的所有子类（如果有子类的话）同时工作。Adapter可以一次给所有的Adaptee添加功能 效果：适配器模式将目标类和适配者类解耦，增加了类的透明性和复用性，灵活性和扩展性好。 桥梁模式（对象结构型模式）：将抽象部分与实现部分分离，使它可以独立的变化 效果： 桥梁模式分离接口和实现部分，提高可扩充性； 实现细节对用户透明； 将强关联改成弱关联； 继承关系是强关联，聚合关系是弱关联 装饰模式（对象结构型模式）：以对客户透明的方式动态给对象添加额外职责，不是通过继承，而是通过组合实现 注意：装饰模式应该遵循里氏代换原则，装饰类必须覆写所有继承的方法 效果：比静态继承更加灵活，避免在层次结构高层的类有太多的特征 装饰模式 vs 适配器模式： 装饰模式增强功能，不改变接口； 适配器模式改变接口，不改变功能 外观模式（对象结构型模式）：设计原则为迪米特法则；提供了一个统一的接口，用来访问子系统中的一群接口；定义一个高层接口，使子系统更加容易使用 效果： 减少客户端的对象数目； 实现了子系统和客户之间松耦合； 不限制客户应用子系统类； 子系统中类的功能收到外观的限制 组合模式（对象结构型模式）：把对象归集成一个树形结构，若是简单的没有组合的基本单位就是叶对象，若节点互相聚集在一起就是组合对象；在组合模式下，树形结构中的节点在工作时无论是单一的还是组合的都会同样处理；通过Component接口操纵组合部件的对象 效果：简化客户代码，一致使用组合对象和单个对象；容易增加新类型的组件； 注意，与装饰模式的对比： 一定程度上，装饰模式是组合模式的一个特例； 装饰对象只能聚集一个对象，动态构建功能； 组合模式把对象组装为一个层次结构 代理模式（对象结构型模式）：为其他对象提供一种代理以控制对这个对象的访问，用代理来替代被访问的实体 类似的模式：代理模式、装饰模式、适配器模式 区别： 代理使用实际对象相同接口，适配器转换了接口 装饰模式为了动态添加功能，代理模式也可以 *享元模式（对象结构型模式）：运用共享技术有效地支持大量细粒度的对象，避免大量拥有相同内容的小类的开销，使大家共享一个对象 第四章 设计模式–行为模式 行为模式是对不同对象之间划分责任和算法的抽象化，它不仅描述类和对象的结构，而且重点关注它们之间的交互和通信 行为型模式分为类行为型模式和对象行为型模式 类行为型模式使用继承机制在类之间分派行为，通过多态等方式分配父类和子类的职责 对象行为型模式使用对象复合而不是继承分配行为，通过对象关联等方式来分配多个类的职责 合成复用原则 模板方法模式（类行为型模式）： 实现父类和子类对象之间职责的划分； 使用继承机制使得父类和子类之间达到分工合作的目的； 基类中确定算法框架，子类实现具体工作； 子类不需要改变算法结构即可重定义算法的某些步骤； 将相同的代码放在父类中，不同的方法放在不同的子类中 效果：模板方法是一种代码复用技术，导致一种反向的控制结构（依赖倒置原则） 命令模式（对象行为型模式）：将请求封装成对象，用不同请求对客户参数化；请求发送者和请求接收者解耦 效果：命令可以被扩展，满足ocp原则 观察者模式（对象行为型模式）： 定义对象间的一种一对多的依赖关系； 当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新 一个对象可以被多个观察者观察，即被观察者和观察者是一对多关系 效果： 目标和观察者之间松耦合，可以各自独立改变； 允许独立改变目标和观察者； 高内聚低耦合； 一个目标被大量订阅，广播通知时会有效率问题 策略模式（对象行为型模式）：定义一系列算法，并进行封装，使其可以相互替换；根据环境条件的不同，选择不同的策略来完成该项任务 strategy类层次为context定义了一系列可供重用的算法，环境类依赖接口，不依赖具体实现 策略模式 vs 装饰模式、模板方法模式： 策略模式实现相同功能，更换策略不改变总体功能； 装饰模式动态增加功能 模板方法父类静态定义算法基本框架，子类只允许改变算法中的步骤 中介者模式（对象行为型模式）：用一个中介对象来封装一系列的对象交互；中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立改变他们之间的交互；为了减少对象两两之间复杂的引用关系 效果： 减少了子类生成；各个同事松耦合； 简化了对象间关联； 控制集中化； 中介者难复用 状态模式（对象行为型模式）：允许一个对象在其内部状态改变时改变他的行为；一个对象与外部事件交互，内部状态改变，其行为也随之变化 适用性：对象行为取决于其状态；一个操作中含有庞大的多分支条件语句 效果： 使用状态模式，动作完成后可以自动切换到下一个状态，客户无需知道具体切换逻辑。每个ConcreteState实例只需要知道本状态后可能过渡到哪些状态及相应条件； 实现了与状态相关的行为的局部化； 使用状态模式将状态的切换逻辑放到state的派生类中，动作的实现供派生类进行调用，实现逻辑和动作的解耦 访问者模式（对象行为型模式）： 表示一个作用于某个对象结构中的各元素的操作； 可在不改变这些对象本身的情况下，定义作用于这些对象的新操作； 封装一些施加于某种数据结构元素之上的操作 为不同类型的元素提供了多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式 效果： 不改变具体元素类，就可以增加新操作，主要是通过元素类的accept方法接受一个visitor对象来实现的 不易频繁增加元素类，每增加一个元素类，就要在visitor接口中写一个针对该元素的方法，还要修改visitor子类 迭代器模式（对象行为型模式）：提供一种可顺序访问聚合对象中各个元素的方法，但不暴露该对象内部表示；提供外部对象使用的迭代器，对聚合访问和遍历 效果： 支持以不同的方式遍历一个集合； 迭代器简化了聚集的接口； 在同一个聚集上可以有多个遍历； 职责链模式（对象行为型模式）： 避免请求的发送者和接收者之间的耦合关系； 多个对象都有机会处理一个请求； 对象连成一条链，沿链传递该请求，直到有对象处理 客户无需关心请求的处理细节和请求的传递，只需将请求发送到链上即可 效果： 降低耦合度； 增强了给对象分配职责的灵活性； 不保证被接受 第四章 设计模式–创建型模式 创建型模式关注的是对象的创建，将创建对象的过程进行抽象； 作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑 工厂模式：专门负责实例化有共同父类（接口）的类的实例；工厂模式可以动态决定实例化哪一个子类对象，不必事先知道要实例化哪个类 简单工厂模式： 在该模式中可以根据参数的不同返回不同类的实例； 专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类 效果： 将对象的创建和对象本身业务处理分离可以降低系统的耦合度； 工厂类的职责过重，增加新的产品要修改工厂类的判断逻辑； 当你需要什么，只需要传入一个正确的参数就可以获取你想要的对象，而无需知道创建细节 总结： 将具体的对象生成，移植到服务端代码的一个对象生成工厂中； 当有需求要增加新的子类对象时，客户端的代码不再需要修改，只需修改服务端代码 工厂模式： 解决了简单工厂模式违反开闭原则问题，增加工厂类的动态性； 定义一个用户创建对象的接口，让子类决定实例化哪一个类； 效果：为子类提供挂钩；连接平行的类层次 总结： 工厂模式中，核心的工厂类不再负责所有产品的创建，而是将具体的创建工作交给子类去做； 增加新产品类时无需修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性； 增加新产品时需要增加新的工厂，导致系统类的个数成对增加，一定程度上增加了系统的复杂性 抽象工厂模式： 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类； 应用于系统独立于其产品创建、组合和表示时； 当系统提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的产品时 效果： 隔离了具体类的生成，使得客户并不需要知道什么被创建，更换一个具体工厂就变得相对容易； 改变具体工厂的实例，就可以在某种程度上改变软件系统的行为； 高内聚低耦合 单例模式（对象创建型模式）：保证一个类仅有一个实例，提供一个全局访问点 效果： 严格控制客户怎样及何时访问它； 对全局变量的一种改进，避免污染名空间； 允许对操作和表示的精化 生成器模式（对象创建型模式）： 逐步构造对象，使得对象的创建更具弹性； 将一个包含多个组件对象的创建分成若干个步骤，并将这些步骤封装在Builder接口中 效果： 使产品的内部表象可以独立变化； 每一个builder相对独立，与其他builder无关； 可对构造过程更加精细控制； 将构建代码和表示代码分开 第五章 架构模式 多视图方法是软件架构归档的方法，更是指导我们进行架构设计的思维方法 软件架构视图：对于从某一视角或某一点上看到的系统所做的简化描述，描述中涵盖了系统的某一特定方面，而省略了于此方面无关的实体 4+1视图： 逻辑架构：关注功能，着重考虑功能需求 开发架构：关注程序包，着重考虑开发期质量属性 运行架构：关注进程、线程、对象等运行时概念及相关的并发同步通信等问题，着重考虑运行期质量属性 物理架构：关注软件系统最终如何安装或部署到物理机器 数据架构：关注持久化数据的存储方案 逻辑视图：关注用户可见的功能，还包括为实现用户功能而必须提供的辅助功能模块 开发视图：关注程序包，不仅包括编写的源程序，还有可以直接使用的第三方SDK和现成框架、类库、中间件 运行视图：关注运行时单元的交互问题 物理视图：重视目标程序的静态位置问题 场景视图：可理解性 分层架构模式： 系统将划分为一个层次结构； 各层之间的关系是客户/服务器； 每一层都具有高度内聚性； 有助于将复杂系统划分成独立模块； 每层都向上层提供服务，同时又利用了下层的逻辑功能 上层通过下层提供的接口来使用下层的功能 优点：减少依赖程度、支持扩展、支持重用 缺点：层次划分不易、不一定能够层次化、系统性能下降、难以调试 管道过滤器架构模式： 过滤器读取数据，加工转换，变成输出数据； 过滤器间通过管道连接； 每个过滤器是独立的实体； 管道传输和缓存数据 优点：简单性；重用性；系统易维护和扩展；并发性 缺点：过滤器对输入数据批量转换；不适合设计交互式应用系统；兼容性弱；降低系统效率 插件架构模式：扩展点用接口表示，插件用于实现这些接口并安装；应用在没有添加扩展时也能正常使用 优点： 每个插件有自己的职责范围； 便于第三方扩展； 保持系统的精简； 支持多版本同时运行； 插件的独立测试 缺点： 初始过程消耗高； 执行过程中管理开销不断提高； 插件和接口有依赖关系 中介模式（分布式系统架构模式）：服务器组件提供一个或多个服务；客户组件需要服务器组件的一个或多个服务 优点：客户无需知道服务器的物理地址；通过服务器的逻辑名称实现了隐藏 缺点：容错性差；间接调用增加了调用的通信开销；中介可能形成拼接 对比： 中介者模式同事通过mediator通信，处在同一系统。发送和接受1：n关系； 中介模式负责分布式系统中确定接受组件位置，发送和接受1：1 SOA架构模式： 把一个业务流程直接构建为一个计算机系统； 应用场景被分配给设计的组件，易于修改； 一个应用场景的目标就是实现一个服务； 一个业务流程会使用这个服务 优点： 根据业务流程构成服务组件； 分解服务组件和基本服务组件，减小系统复杂性； 可复用； 接口不变，服务的实现可动态转换 缺点： 过于细分服务组成复杂的结构； 多个层次通信增加额外开销 MVC模式： 模型（核心功能）封装系统数据和对数据的加工； 视图把数据展示给用户，含有模型要展示的数据； 控制器负责接收用户的输入，对输入的内容进行解释 优点： 模型类和用户界面分别设计； 修改界面无需更改模型；模型单独测试； 同一应用设计不同用户界面 缺点： 经常更新影响系统性能； 细分多个类增加实现开销]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>复习提纲</tag>
        <tag>软件设计与体系结构</tag>
      </tags>
  </entry>
</search>
