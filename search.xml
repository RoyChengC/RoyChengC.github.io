<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode 38 Count and Say]]></title>
    <url>%2F2019%2F04%2F08%2Fleetcode-38-Count-and-Say%2F</url>
    <content type="text"><![CDATA[38. Count and SayThe count-and-say sequence is the sequence of integers with the first five terms as following: 123451. 12. 113. 214. 12115. 111221 1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: 12Input: 1Output: &quot;1&quot; Example 2: 12Input: 4Output: &quot;1211&quot; 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, “one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 思路可以用递归法求解。报一个数字，只需要知道前面一个的结果，在根据前一个结果计算应该报的数。 每次递归取前一个的结果，遍历一遍前一个结果，并定义一个 count 计数器，统计重复数字的个数，遍历第 i 次的结果为 count 个 prev[i]。 123456789101112131415161718192021class Solution &#123; public String countAndSay(int n) &#123; if (n == 1) &#123; return "1"; &#125; else &#123; String prev = countAndSay(n - 1); String result = ""; int count; int len = prev.length(); for (int i = 0; i &lt; len; ++i) &#123; count = 1; while (i + 1 &lt; len &amp;&amp; prev.charAt(i) == prev.charAt(i + 1)) &#123; count++; i++; &#125; result += Integer.toString(count) + prev.charAt(i); &#125; return result; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 35 Search Insert Position]]></title>
    <url>%2F2019%2F04%2F08%2Fleetcode-35-Search-Insert-Position%2F</url>
    <content type="text"><![CDATA[35. Search Insert PositionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: 12Input: [1,3,5,6], 5Output: 2 Example 2: 12Input: [1,3,5,6], 2Output: 1 Example 3: 12Input: [1,3,5,6], 7Output: 4 Example 4: 12Input: [1,3,5,6], 0Output: 0 给定一个排好序的数组和一个目标值，如果目标值在数组中出现了，返回目标值在数组中的下标，否则返回目标值插入数组后的下标。 思路可以直接遍历一遍数组，若当前数字大于或等于目标值，则返回当前坐标，如果遍历结束了，说明目标值比数组中任何一个数都要大，则返回数组长度n即可。 我们还可以使用二分查找法优化时间复杂度。 123456789101112class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while (high &gt; low) &#123; int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) high = mid; else low = mid + 1; &#125; return low; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 167 Two Sum II - Input array is sorted]]></title>
    <url>%2F2019%2F04%2F08%2Fleetcode-167-Two-Sum-II-Input-array-is-sorted%2F</url>
    <content type="text"><![CDATA[167. Two Sum II - Input array is sortedGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 123Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 给定一个升序排序的整数数组 numbers，在这个数组中找两个数字，使得这两个数字相加等于给定目标数字 target，找到之后返回这两个数字的下标 + 1。 思路可以使用双指针法，用一个指针 low 指向数组头部，另一个指针 high 指向数组尾部。然后在遍历这个数组时，判断 numbers[low] + numbers[high] 是否为 target。当 numbers[low] + numbers[high] &lt; target，说明 numbers[low] 这个数字偏小，需要将 low + 1；当 numbers[low] + numbers[high] &gt; target，说明 numbers[high] 这个数字偏大，需要将 high - 1。 1234567891011121314class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int low = 0, high = numbers.length - 1; while (low != high) &#123; int sum = numbers[low] + numbers[high]; if(sum &gt; target) high--; else if (sum &lt; target) low++; else &#123; return new int[] &#123;low + 1, high + 1&#125;; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记: int 和 Integer 的区别]]></title>
    <url>%2F2019%2F04%2F07%2FJava%E7%AC%94%E8%AE%B0-int-%E5%92%8C-Integer-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[int 和 Integer 有什么区别基本知识int 也就是整型数字，是 Java 的 8 个原始数据类型之一。Java 虽然号称一切都是对象，但原始数据类型是个例外。 Integer 是 int 对应的包装类，这个类中包含一个 int 类型的字段存储数据，并且提供了数学运算、int 和字符串之间的转换等基本操作。在 Java 5 中，提供了自动装箱和自动拆箱功能，Java 可以根据上下文，自动进行转换。 我们一般使用 new 关键字构建一个 Integer 对象，而大部分数据操作都是集中在有限的较小的数值范围，因此，Java 5 中新增了静态方法 valueOf，在调用它的时候会利用一个缓存机制。这个值默认缓存在 -128~127 之间。 . 知识扩展1.自动装箱、自动拆箱 自动装箱、自动拆箱其实是一种语法糖，即 Java 为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。 javac 把自动装箱转换为 Integer.valueOf()，把拆箱转换为 Integer.intValue()。 在编程实践中，我们应避免不必要的装箱拆箱行为。因为 Integer 是一个对象，创建多个对象的开销是比创建多个整数的开销多的。 2.原始类型线程安全 原始数据类型的变量，显然要使用并发相关手段，才能保证线程安全。如果有线程安全的需要，建议使用类似 AtomicInteger、AtomicLong 这样的线程安全类。]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java笔记: String、StringBuffer、StringBuilder 有什么区别]]></title>
    <url>%2F2019%2F04%2F07%2FJava%E7%AC%94%E8%AE%B0-String%E3%80%81StringBuffer%E3%80%81StringBuilder-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[String、StringBuffer、StringBuilder 有什么区别. 基础知识String：在 Java 中，String 被声明为 final class，所有的属性也都是 final 的。由于 String 的不可变性，类似字符串的拼接、剪切等动作，都会产生新的 String 对象。而对字符串的操作是很普遍的，所以相关操作的效率会对应用性能有影响。 StringBuffer：StringBuffer 是为了解决字符串拼接时产生的大量中间对象的问题而提供的一个类，具体的拼接方法有 append 和 add。StringBuffer 可以保证线程安全，但是也随之带来了额外的性能开销。所以除非有线程安全的需要，不然还是推荐使用 StringBuilder。 StringBuilder：在功能上与 StringBuffer没有本质区别，但是它去除了线程安全部分，减小了开销，是绝大部分情况下进行字符串拼接的首选。 知识扩展1.字符串设计和实现 之前讲到 String 是 Immutable 类，它也能保证线程安全，因为你不能对它内部的数据进行任何修改。 再看 StringBuffer 类实现的一些细节，它的线程安全功能是通过把各种修改数据的方法都加上 synchronized 关键字实现的，非常简单粗暴。其实这样的实现方式非常适合我们常见的线程安全类的实现。 为了实现字符串的拼接，StringBuffer 和 StringBuilder 底层都是利用可修改的数组（char 类型，JDK9 以后是 byte）数组，两者都是继承自 AbstractStringBuilder，区别仅在于方法是否加了 synchronized。 这个可修改的数组目前的实现是，构建时初始字符串长度加16，也就是说如果没有构建对象时输入的字符串，那么初始值就是16。 在日常编程中，还是要保证代码的可读性、可维护性，这往往比最优性能更重要。 . 2.字符串常量池 在我们的日常编程中，String 的使用是很频繁的，Java 为了避免在一个系统中产生大量的 String 对象，引入了字符串常量池。在创建一个字符串时，首先检查常量池中是否有对应值的字符串对象，如果有则直接创建从池中查找到的对象引用，如果没有则新建一个 String 对象，返回对象引用，并将新创建的对象放入常量池。但是通过 new 的方式创建的 String 对象是不会去搜索常量池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入常量池中。 12String str1 = "123"; //通过直接量赋值方式，放入字符串常量池String str2 = new String(“123”);//通过new方式赋值方式，不放入字符串常量池 String 在 Java 6 以后还提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 intern() 方法时，如果已经有缓存的字符串，就会返回缓存中的实例，否则将其缓存起来。 . 3.应用场景 在字符串内容不经常发生变化的场景优先使用 String 类。如：常量声明、少量的字符串拼接操作等。如果有大量字符串拼接操作，应避免使用 String 与 String 之间的 ”+“ 操作。 在频繁进行字符串拼接、替换、删除等，并且运行在多线程环境下，建议使用 StringBuffer，例如 XML 解析、HTTP 参数解析与封装。 在频繁进行字符串拼接、替换、删除等，并且运行在单线程环境下，建议使用 StringBuilder，例如 SQL 语句拼接、JSON 封装等。]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java笔记: 强引用、软引用、弱引用、幻象引用有什么区别]]></title>
    <url>%2F2019%2F04%2F04%2FJava%E7%AC%94%E8%AE%B0-%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[强引用、软引用、弱引用、幻象引用有什么区别1.强引用 我们平常写代码的时候使用 Object obj = new Object() 中的 obj 就是强引用，即通过关键字 new 创建的对象所关联的引用就是强引用。当 JVM 内存不足时，JVM 宁愿抛出 OutOfMemoryError 运行时错误，使程序异常中止，也不会随意回收具有强引用的存活对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式的将相应（强）引用赋值为 null，就是可以被垃圾回收的了。 2.软引用 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象，即 JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。后续我们可以调用 ReferenceQueue 的 poll() 方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个 null ，否则该方法返回队列中前面的一个 Reference 对象。 应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 3.弱引用 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。 应用场景：弱应用同样可用于内存敏感的缓存。 4.幻象引用（虚引用） 无法通过幻象引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 后，做某些事情的机制。如果一个对象仅持有幻象引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。 应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java笔记: 对Java平台的理解]]></title>
    <url>%2F2019%2F03%2F29%2FJava%E7%AC%94%E8%AE%B0-%E5%AF%B9Java%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[对Java平台的理解Java 最显著的特性有两个方面，一个是“书写一次，到处运行”，即 Java 拥有跨平台的能力；第二个是垃圾收集机制（GC），Java 通过垃圾收集器回收和分配内存。 我们经常见到 JDK 和 JRE，JRE（Java Runtime Environment）是 Java 运行环境，它包含了 JVM 和 Java 类库等；JDK 提供了更多工具，如编译器和诊断工具。 Java 是解释执行的吗这个说法不太准确。我们编写的 Java 源码首先通过 Javac 编译成字节码，然后在运行时通过 Java 虚拟机内嵌的解释器将字节码转换成最终的机器码。Java 通过字节码和 Java 虚拟机这种跨平台的抽象，屏蔽了操作系统和硬件的细节，这是“书写一次，到处运行”的基础。 但是常见的 JVM 都提供了 JIT（Just-In-Time）编译器，即动态编译器，JIT 能够在运行是将热点代码编译成机器码，这种情况就是编译执行。 Java 知识扩展]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java笔记: Exception和Error有什么区别]]></title>
    <url>%2F2019%2F03%2F28%2FJava%E7%AC%94%E8%AE%B0-Exception%E5%92%8CError%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Exception和Error有什么区别Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出或捕获，它是异常处理机制的基本组成类型。 Exception 是程序正常运行中，可以预料的情况，应该被捕获，进行相应处理。Exception 又分为可检查异常和不检查异常，可检查异常在程序中必须显式的进行捕获。不检查异常即运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 等，通常是可以解决的逻辑错误。 Error 指在正常情况下不太可能出现的情况，绝大多数 Error 都会导致程序处于非正常的、不可恢复的状态，因此 Error 不便于也不需要捕获。 注意事项 在 try-catch 语句中尽量不要使用类似 Exception 这样的通用异常，而应该捕获具体的异常，像 NullPointerException 等 不要忽略异常。如果我们不把异常抛出来，或者也没有输出到日志，程序可能在后续代码以不可控的方式结束]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java笔记: final、finally、finalize有什么不同]]></title>
    <url>%2F2019%2F03%2F27%2FJava%E7%AC%94%E8%AE%B0-final%E3%80%81finally%E3%80%81finalize%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[Java笔记: final、finally、finalize有什么不同 final可用来修饰类、变量和方法。 final修饰类表示这个类不能继承； final修饰变量代表该变量不能被修改； final修饰方法表示该方法不能被重写，即override。 finally是一种将某段代码必须被执行的机制。多使用try-catch-finally或try-finally来关闭JDBC连接。 finalize 是基础类 java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为deprecated。 作用： final可以在某些场景中提高程序的性能。 finally用于关闭连接等资源 12345678try &#123; // do something System.exit(1);&#125; finally&#123; System.out.println(“Print from finally”);&#125;// finally中的代码不会执行 finalize的执行与垃圾收集关联在一起 注意： final不等同于immutable（不可改变） 1234567 final List&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add("Hello"); strList.add("world"); List&lt;String&gt; unmodifiableStrList = List.of("hello", "world"); unmodifiableStrList.add("again");// final只能约束strList不能被赋值，但是strList对象的行为不被约束 不要在finally中使用return语句 可以使用 java.lang.ref.Cleaner 取代 finalize 实现]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 24 Swap Nodes in Pairs]]></title>
    <url>%2F2019%2F03%2F26%2Fleetcode-24-Swap-Nodes-in-Pairs%2F</url>
    <content type="text"><![CDATA[24. Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. 给你一个链表，交换每两个相邻的节点（两个节点一对，一对一对交换）。 Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 思路： 就是普通的交换两个节点，但是要注意一对节点中的第二个节点与下一对节点的第一个节点的连接关系。 1234567891011121314151617class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* res = new ListNode(-1); ListNode* cur = res; res-&gt;next = head; while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL) &#123; ListNode* temp = cur-&gt;next-&gt;next; cur-&gt;next-&gt;next = temp-&gt;next; temp-&gt;next = cur-&gt;next; cur-&gt;next = temp; cur = temp-&gt;next; &#125; return res-&gt;next; &#125;&#125;; 进阶： 以下内容出自http://www.cnblogs.com/grandyang/p/4441680.html 这题还可以使用递归方法，利用了回溯的思想，递归遍历到链表末尾，然后先交换末尾两个，然后依次往前交换。 12345678910class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode *t = head-&gt;next; head-&gt;next = swapPairs(head-&gt;next-&gt;next); t-&gt;next = head; return t; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-23 Merge K Sorted Lists]]></title>
    <url>%2F2019%2F03%2F24%2Fleetcode-23-Merge-K-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[23. Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 合并k个有序链表，返回一个排好序的链表。 Example: 1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路： 把k个链表中的元素一一取出，并将它们放入一个vector中，之后对vector进行排序。最后将排序好的vector转化成链表即可。 123456789101112131415161718192021222324class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; vector&lt;int&gt; vec; int n = lists.size(); for (int i = 0; i &lt; n; ++i) &#123; ListNode* node = lists[i]; while (node != NULL) &#123; vec.push_back(node-&gt;val); node = node-&gt;next; &#125; &#125; sort(vec.begin(), vec.end()); ListNode head(0); ListNode* result = &amp;head; for (int i = 0; i &lt; (int)vec.size(); ++i) &#123; ListNode* temp = new ListNode(vec[i]); result-&gt;next = temp; result = result-&gt;next; &#125; return head.next; &#125;&#125;; 进阶： 以下出自http://www.cnblogs.com/grandyang/p/4606710.html 之前有一道合并两个有序链表链表的题目（21. Merge Two Sorted Lists），我们同样可以通过两两合并来解决这道问题，但是这样做时间复杂度太高。 我们可以通过最小堆解决这个问题。首先把k个链表的首元素都加入最小堆中，它们会自动排好序。然后我们每次取出最小的那个元素加入我们最终结果的链表中，然后把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆中没有元素了，此时k个链表也合并为了一个链表，返回首节点即可。 1234567891011121314151617181920class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto cmp = [](ListNode*&amp; a, ListNode*&amp; b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp) &gt; q(cmp); for (auto node : lists) &#123; if (node) q.push(node); &#125; ListNode *dummy = new ListNode(-1), *cur = dummy; while (!q.empty()) &#123; auto t = q.top(); q.pop(); cur-&gt;next = t; cur = cur-&gt;next; if (cur-&gt;next) q.push(cur-&gt;next); &#125; return dummy-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>排序</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件构造复习提纲]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[Part 1软件构造是编码加调试，包括部分的详细设计和单元测试、集成测试以及其他活动，即软件构造不等于编码实现 测试是为了发现错误，调试是为了确定错误的位置并修改错误 SOA–service oriented architecture 面向服务的架构模型：一个服务有多个消费者，每个消费者都对服务有自己特定的期望，服务供应商应该演化以满足期望的变化 CDC–consumer driven contract 消费者驱动契约：解决SOA问题 支持契约式编程的语言Eiffel 契约式编程：根据事先给定的前置条件、后置条件和不变式来实现代码 隐喻并非是简单的用一个名词对软件事务进行类比，还包含了对类比的事物之间的体验和分析 隐喻更像启示，而不是算法，帮助开发人员加深对编程的理解 软件构造的前期准备工作的目标：降低风险，避免糟糕的需求分析和项目计划 软件项目类型：性命攸关（序列式开发）、使命攸关、一般商业系统（迭代式开发） 序列式开发：使用瀑布模型、适用于需求稳定的情况，设计简单，后期更改代价高 迭代式开发：整个工作被组织成一系列迭代过程，适用于需求经常变更的情况，设计复杂，后期更改代价低 RUP(Rational Unified Process)：统一软件开发过程 开始构建的先决条件：明确问题定义（整个开发的基础）、明确需求规约、明确的架构设计（软件设计的高层部分） 需求定义：详细规定了软件系统应该做什么 软件架构的组成：程序组织、主要的类、数据设计、业务规则、UI设计、安全性、错误处理、容错性、变更策略、国际化/本地化 软件架构的两个要素：元件划分、设计决定 80/20原则 前期准备：10-20%的工作量、20-30%的时间 Part 2软件的首要技术使命：管理复杂度 理想的设计特征：最大程度降低复杂化、易于维护、可扩展性、可复用性、可移植性、高扇入低扇出、松耦合 设计的层次：软件系统、分解成子系统和包、分解成包中的类、分解成类中的子程序和数据、子程序内部 子程序：具有一定功能的，可以调用的函数或过程 模块：数据及作用于数据的子程序的集合 为什么要模块化：提高维护性 模块独立程度的衡量标准：内聚性、耦合性 内聚性：一个模块/子程序内各种操作之间互相联系的紧密程度–每个模块/子程序只做一个工作 耦合性：软件结构内各个模块的关联程度 内聚性：功能内聚（最高）、顺序内聚（较高）、通讯内聚（中）、临时内聚（中）、过程内聚、偶然内聚（低）、时间内聚（低）、逻辑内聚（低） 耦合性：无任何连接、数据耦合、控制耦合、公共环境的耦合、内容耦合 过程内聚和顺序内聚的区别：使用的数据是不同的/使用的数据是相同的 模块的封装部分是内部信息，公开部分是接口和公开信息 常见需要隐含的信息：容易被改动的区域、复杂的数据、复杂的逻辑 模块包括：数据、数据类型、数据操作、公共和局部操作 ADT：一组数据和对应这组数据的操作的集合 类：一组数据和子程序的集合 ADT + 封装、继承、多态 = 类，而ADT是弱封装 类接口提供了类公开的操作，普通接口只提供了操作的声明 类接口需要一致的抽象、良好的封装 继承：一个类是另一个类的特化–is a 关系 包含：一个类中拥有另一个类–has a 关系 包含通过成员数据来实现，不得已的情况下可以用private的继承实现has a关系 用public继承实现is a关系 LSP原则使得继承降低复杂度 接口继承：子接口是父接口的扩充或细化 实现继承：派生类同时继承函数的接口和实现部分 慎用 实现继承会带来更多的耦合问题 继承关系容易产生基类和子类的强耦合 Part 3墨菲法则：所有有可能出错的事物终将出错–所有的程序都有缺陷 防御式编程的目标：提高代码质量、提高代码可读性、使程序运行可预测、保护程序免受非法数据的破坏 断言：表示程序运行到此处需要满足的条件，能使程序运行时自检 断言 = 布尔表达式 + 断言不成立输出的信息 错误处理代码：检查预期发生的状况，检查有害的输入数据 断言：检查绝不该发生的情况，检查是否有bug 避免把需要运行的代码放到断言中；一般先使用断言，在使用错误处理代码；用断言注释并验证前条件和后条件 错误处理技术：返回中立值、返回下一个正确的值、返回上一个正确的值、输出错误信息、关闭程序。。。 异常：把代码中的错误或异常事件传递给调用方代码的一种特殊手段 异常结构：子程序使用throw抛出异常对象，再传递给上层；try-catch捕获异常 异常处理机制涉及的要素：异常对象、异常对象的抛出、异常的捕获 finally：关闭流、关闭连接、释放销毁资源 C++提供RAII机制取代finally RAII（Resource Acquisition is Initialization）：资源获取即初始化，资源从析构函数释放 finally针对特定应用，RAII针对资源本身 隔离部分是脏数据，应使用错误处理技术；隔离区内部的是干净数据，应使用断言机制 去除检查细微错误，使程序硬性崩溃的代码 保留检查重大错误，使程序稳妥崩溃的代码，记录错误信息的代码 Part 4变量定义和声明的规则：关闭隐式声明，声明所有变量，遵循命名规则 变量初始化原则：在声明时初始化，在靠近变量第一次使用的时候声明和初始化，需要的情况下使用final和const，注意累加器和计数器，使用构造函数初始化 变量作用域：使变量引用局部化，缩短变量的生存时间 减小跨度和攻击窗口 以上增强可读性和可维护性 变量与数值的绑定时间越晚越好 绑定时间的种类：编码时，编译时，加载时，对象实例化时，即时 数据类型与控制结构的关系：序列型数据–顺序，选择型数据–if/case，迭代型数据–循环 Part 5语句类型：顺序型语句，条件语句，控制循环语句，特殊控制结构，表驱动法 条件语句使用原则：首先写代码的正常路劲，在处理其他情况，把异常代码路径当作防卫语句处理；把正常情况放在if后面，if子句应该有意义；用布尔函数简化判断；小心使用switch 循环的种类：计数循环，连续求值的循环，无限循环，迭代器循环 带退出的循环：退出条件应该放在一处，用注释阐明操作意图 把循环看作黑盒子 进入循环：尽量在一个地方进入循环，在循环之前初始化，如何选择while/for循环 循环体：明确循环体的部分（用大括号包围），避免空循环，注意循环内务操作应放在开始或结尾 循环内务操作：控制循环的变量，如 i++ 退出循环：明确退出循环的条件，避免使用最终的循环下标取值 不常见的控制结构/特殊的控制结构：子程序中多处返回，goto，递归 多处返回的原则：增强可读性，用防卫子句简化逻辑 递归：确保递归终止条件，用安全计数器防止无限递归，避免循环递归 goto：goto增加复杂度，降低程序性能，格式难以安排 / 可减少重复代码，加快运行速度；不能随意使用 表驱动法：直接访问，索引访问，阶梯访问 Part 6协同构建包括：代码集体所有，代码评审，结对编程 协同构建的目的是改善代码质量 代码集体所有的好处：提高代码质量，人员离开项目的影响减少，改错的周期减少 结对编程：增加10-25%成本，节省45%时间 评审包括：检视/审查/详查（Inspection，正式的）、走查（Walkthrough，非正式的）、技术评审（Technical Review，正式的） 评审步骤：计划、概述（可选）、准备、详查会议、第三个小时的会议（可选）、返工、跟进 开发者测试：单元测试、组件测试、集成测试、回归测试、系统测试 测试又分为黑盒和白盒测试 开发者测试占整个项目时间的8-25% 传统的开发者测试是单元和集成测试 重构的类型：数据级的重构、语句级的重构、子程序级的重构、类实现的重构、类接口的重构、系统级的重构 重构：在不改变软件的外部行为的条件下，对其内部结构进行改变，使之更容易理解和修改 安全的重构：保存原始代码、设置检查点、减缓重构的步伐（每次重构小部分）。。。 重构策略：关注高复杂度的模块、关注易错的模块、修改缺陷时重构。。。 代码调优（code tuning）：修改正确的代码使其更有效地运行；调优一般是影响一个类或几行代码的小规模更改 注意代码调优和重构的区别 管理构建的关键问题—-如何鼓励良好的编程实践 配置管理：系统化地定义项目的工作和处理变化，使项目一直保持其完整性的实践活动 Part 7图灵机的思想：用机器来模拟人们用纸笔进行数学运算的过程（在纸上写下或擦除某种符号，把注意力从纸的一个位置移动到另一个位置） 图灵机的原理/构造：无限长带有小格子的纸带，读写头，控制规则表，状态寄存器 七元组：{ Q，Σ，Γ，δ，q0, qaccept, qreject }，Q相当于状态寄存器，Σ相当于无限长的纸带，δ相当于控制规则表，q0是起始状态，qaccept是接受状态，qreject是拒绝状态 形式文法：G = { V, T, S, P }，V相当于Γ，S相当于q0，P相当于δ 基于代数和逻辑的方法：larch，clear，obj，cafeobj 基于模型的方法：z，b，vdm，object-z 敏捷开发模式 TDD(Test Driven Development) 测试驱动开发 TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。 BDD(Behavior Driven Development) 行为驱动开发 行为驱动开发是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。主要是从用户的需求出发，强调系统行为。 ATDD(Acceptance Test Driven Development) 验收测试驱动开发 在准备实施一个功能或特性之前，团队首先需要定义出期望的质量标准和验收细则，以明确且达成共识的验收测试计划（包含一系列测试场景）来驱动开发人员的功能开发实现和测试人员的测试脚本开发。 DDD(Domain Driven Design) 领域驱动开发 领域驱动设计是对面向对象的的分析和设计（OOAD，Object Orient Analysis Design）的一个补充，对技术框架进行了分层规划，同时对每个类进行了策略和类型划分。 FDD(Feature Driven Development) 特征驱动开发 它强调特性驱动，快速迭代，即能保证快速开发，又能保证适当文档和质量，非常适合中小型团队开发管理。它提出的每个功能开发时间不超过两周，为每个用例限定了粒度，具有良好可执行性，也可以对项目的开发进程进行精确及时地监控。 用户故事 用户故事是描述对用户有价值的功能，好的用户故事应该包括角色、功能和商业价值三个要素。用户故事通常的格式为：作为一个&lt;角色&gt;, 我想要&lt;功能&gt;, 以便于&lt;商业价值&gt;。 一个好的用户故事包括三个要素： ​ 角色：谁要使用这个功能。 ​ 功能：需要完成什么样的功能。 ​ 商业价值：为什么需要这个功能，这个功能带来什么样的价值。 Scrum迭代式增量软件开发过程、XP极限编程 Scrum偏重于过程，XP则偏重于实践 Scrum开发流程的三大角色 产品负责人(Product Owner)：主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。 流程管理员(Scrum Master)：主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。 开发团队(Scrum Team)：主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。 Scrum开发模型 产品需求列表 Product Backlog：由Product Owner负责，提供用户故事 迭代 Sprint：一次Sprint Backlog完成，表示一次Sprint完成 迭代计划会议 Sprint Planning Meeting：形成Sprint Backlog 迭代任务列表 Sprint Backlog：由Scrum Team完成 每日站立会议 Daily Scrum Meeting 迭代燃尽图 Sprint Burn Down 迭代演示会议 Sprint Review Meeting：Sprint完成后的评审会议，演示软件产品 迭代回顾会议 Sprint Retrospective Meeting：总结会议，总结讨论需要改进的地方，放入下一轮Sprint的产品需求中 XP极限编程 eXtreme Programming 它强调程序设计团队与业务专家之间的紧密协作、面对面的沟通（比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好的适应需求变化的代码编写和团队组织方法，更注重软件开发中人的作用。 XP中包含的概念：持续集成CI(Continuous Integration)、结对编程]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件构造</tag>
        <tag>复习提纲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计与体系结构复习提纲]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[第一章 面向对象设计 面向对象设计原则：单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、合成复用原则、迪米特法则 单个类关注：抽象、封装、信息隐藏；多个合作类关注：松耦合、开闭、里氏、依赖倒置、契约式设计 可读性（封装、抽象、信息隐藏、关注点分离、单一职责）、正确性（LSP、契约式设计）、可扩展性（接口隔离、松耦合、LSP、开闭、依赖倒置） 开闭原则是面向对象设计的核心，带来可重用性和可维护性，关键是抽象 里氏替换原则，与继承相关；若能用基类，则能用子类 依赖倒置原则：高层模块不应该依赖低层模块，应该依赖抽象；可以创建可重用框架；针对接口编程而不是针对实现编程 接口隔离原则：处理胖接口（接口不内聚），避免接口污染（为借口添加了不必要的职责），将大接口细化成小接口 单一职责原则：关注点分离，实现高内聚低耦合，一个类应该有且仅有一个职责 契约式设计 第二章 软件架构 软件架构涉及设计模式和架构模式 架构降低复杂度，规定系统的结构和实施流程 系统架构包括：分解成组件、分配组件、组件的相互作用、架构的静态和动态的功能 系统架构可以包含多个架构模式 架构模式可以包含多个设计模式 系统分为多种类型：硬实时系统、软实时系统、非实时系统 系统中的分析任务：明确系统的目的和主要任务、应用流程、接口 系统中的结构设计任务：整体硬件架构 软件架构的原型：水平原型、垂直原型、可行性原型 第三章 软件设计的模式 模式促进软件开发的发展，模式是一个抽象类或接口的符号 模式的主要目标：提高架构的灵活性和可扩展性 模式提高了系统的扩展性、降低了系统的性能、增加了架构的复杂度 设计模式描述的是细致的模式，架构模式是粗略的模式 架构模式描述软件系统里的基本的结构组织或纲要 第四章 设计模式–结构型模式 设计模式：描述复杂软件系统中普遍存在，重复出现的结构、模式、套路，用来解决在一定的场景下，具有一般性的设计问题 模式的核心思想：增加抽象层，分离出变化部分 设计模式分类（按目的）：创建型、结构型、行为型 设计模式分类（按范围）：类模式、对象模式 设计模式解决设计问题：寻找合适的对象、决定对象的粒度、指定对象的接口、描述对象的实现、运用复用机制、运行时刻和编译时刻的结构、设计应支持变化 结构型模式：如何将类或对象结合在一起形成更大的结构，可分为类结构型模式（类之间的静态继承）和对象结构型模式（对象在运行时可以发生变化） 适配器模式：将一个类的接口转换成客户期望的另一个接口 类适配器：用一个具体的adapter类对adaptee和target进行匹配，adapter类多重继承adaptee和target类 对象适配器：允许一个Adapter与多个Adaptee同时工作，即Adaptee本身以及它的所有子类（如果有子类的话）同时工作。Adapter可以一次给所有的Adaptee添加功能 效果：适配器模式将目标类和适配者类解耦，增加了类的透明性和复用性，灵活性和扩展性好。 桥梁模式（对象结构型模式）：将抽象部分与实现部分分离，使它可以独立的变化 效果： 桥梁模式分离接口和实现部分，提高可扩充性； 实现细节对用户透明； 将强关联改成弱关联； 继承关系是强关联，聚合关系是弱关联 装饰模式（对象结构型模式）：以对客户透明的方式动态给对象添加额外职责，不是通过继承，而是通过组合实现 注意：装饰模式应该遵循里氏代换原则，装饰类必须覆写所有继承的方法 效果：比静态继承更加灵活，避免在层次结构高层的类有太多的特征 装饰模式 vs 适配器模式： 装饰模式增强功能，不改变接口； 适配器模式改变接口，不改变功能 外观模式（对象结构型模式）：设计原则为迪米特法则；提供了一个统一的接口，用来访问子系统中的一群接口；定义一个高层接口，使子系统更加容易使用 效果： 减少客户端的对象数目； 实现了子系统和客户之间松耦合； 不限制客户应用子系统类； 子系统中类的功能收到外观的限制 组合模式（对象结构型模式）：把对象归集成一个树形结构，若是简单的没有组合的基本单位就是叶对象，若节点互相聚集在一起就是组合对象；在组合模式下，树形结构中的节点在工作时无论是单一的还是组合的都会同样处理；通过Component接口操纵组合部件的对象 效果：简化客户代码，一致使用组合对象和单个对象；容易增加新类型的组件； 注意，与装饰模式的对比： 一定程度上，装饰模式是组合模式的一个特例； 装饰对象只能聚集一个对象，动态构建功能； 组合模式把对象组装为一个层次结构 代理模式（对象结构型模式）：为其他对象提供一种代理以控制对这个对象的访问，用代理来替代被访问的实体 类似的模式：代理模式、装饰模式、适配器模式 区别： 代理使用实际对象相同接口，适配器转换了接口 装饰模式为了动态添加功能，代理模式也可以 *享元模式（对象结构型模式）：运用共享技术有效地支持大量细粒度的对象，避免大量拥有相同内容的小类的开销，使大家共享一个对象 第四章 设计模式–行为模式 行为模式是对不同对象之间划分责任和算法的抽象化，它不仅描述类和对象的结构，而且重点关注它们之间的交互和通信 行为型模式分为类行为型模式和对象行为型模式 类行为型模式使用继承机制在类之间分派行为，通过多态等方式分配父类和子类的职责 对象行为型模式使用对象复合而不是继承分配行为，通过对象关联等方式来分配多个类的职责 合成复用原则 模板方法模式（类行为型模式）： 实现父类和子类对象之间职责的划分； 使用继承机制使得父类和子类之间达到分工合作的目的； 基类中确定算法框架，子类实现具体工作； 子类不需要改变算法结构即可重定义算法的某些步骤； 将相同的代码放在父类中，不同的方法放在不同的子类中 效果：模板方法是一种代码复用技术，导致一种反向的控制结构（依赖倒置原则） 命令模式（对象行为型模式）：将请求封装成对象，用不同请求对客户参数化；请求发送者和请求接收者解耦 效果：命令可以被扩展，满足ocp原则 观察者模式（对象行为型模式）： 定义对象间的一种一对多的依赖关系； 当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新 一个对象可以被多个观察者观察，即被观察者和观察者是一对多关系 效果： 目标和观察者之间松耦合，可以各自独立改变； 允许独立改变目标和观察者； 高内聚低耦合； 一个目标被大量订阅，广播通知时会有效率问题 策略模式（对象行为型模式）：定义一系列算法，并进行封装，使其可以相互替换；根据环境条件的不同，选择不同的策略来完成该项任务 strategy类层次为context定义了一系列可供重用的算法，环境类依赖接口，不依赖具体实现 策略模式 vs 装饰模式、模板方法模式： 策略模式实现相同功能，更换策略不改变总体功能； 装饰模式动态增加功能 模板方法父类静态定义算法基本框架，子类只允许改变算法中的步骤 中介者模式（对象行为型模式）：用一个中介对象来封装一系列的对象交互；中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立改变他们之间的交互；为了减少对象两两之间复杂的引用关系 效果： 减少了子类生成；各个同事松耦合； 简化了对象间关联； 控制集中化； 中介者难复用 状态模式（对象行为型模式）：允许一个对象在其内部状态改变时改变他的行为；一个对象与外部事件交互，内部状态改变，其行为也随之变化 适用性：对象行为取决于其状态；一个操作中含有庞大的多分支条件语句 效果： 使用状态模式，动作完成后可以自动切换到下一个状态，客户无需知道具体切换逻辑。每个ConcreteState实例只需要知道本状态后可能过渡到哪些状态及相应条件； 实现了与状态相关的行为的局部化； 使用状态模式将状态的切换逻辑放到state的派生类中，动作的实现供派生类进行调用，实现逻辑和动作的解耦 访问者模式（对象行为型模式）： 表示一个作用于某个对象结构中的各元素的操作； 可在不改变这些对象本身的情况下，定义作用于这些对象的新操作； 封装一些施加于某种数据结构元素之上的操作 为不同类型的元素提供了多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式 效果： 不改变具体元素类，就可以增加新操作，主要是通过元素类的accept方法接受一个visitor对象来实现的 不易频繁增加元素类，每增加一个元素类，就要在visitor接口中写一个针对该元素的方法，还要修改visitor子类 迭代器模式（对象行为型模式）：提供一种可顺序访问聚合对象中各个元素的方法，但不暴露该对象内部表示；提供外部对象使用的迭代器，对聚合访问和遍历 效果： 支持以不同的方式遍历一个集合； 迭代器简化了聚集的接口； 在同一个聚集上可以有多个遍历； 职责链模式（对象行为型模式）： 避免请求的发送者和接收者之间的耦合关系； 多个对象都有机会处理一个请求； 对象连成一条链，沿链传递该请求，直到有对象处理 客户无需关心请求的处理细节和请求的传递，只需将请求发送到链上即可 效果： 降低耦合度； 增强了给对象分配职责的灵活性； 不保证被接受 第四章 设计模式–创建型模式 创建型模式关注的是对象的创建，将创建对象的过程进行抽象； 作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑 工厂模式：专门负责实例化有共同父类（接口）的类的实例；工厂模式可以动态决定实例化哪一个子类对象，不必事先知道要实例化哪个类 简单工厂模式： 在该模式中可以根据参数的不同返回不同类的实例； 专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类 效果： 将对象的创建和对象本身业务处理分离可以降低系统的耦合度； 工厂类的职责过重，增加新的产品要修改工厂类的判断逻辑； 当你需要什么，只需要传入一个正确的参数就可以获取你想要的对象，而无需知道创建细节 总结： 将具体的对象生成，移植到服务端代码的一个对象生成工厂中； 当有需求要增加新的子类对象时，客户端的代码不再需要修改，只需修改服务端代码 工厂模式： 解决了简单工厂模式违反开闭原则问题，增加工厂类的动态性； 定义一个用户创建对象的接口，让子类决定实例化哪一个类； 效果：为子类提供挂钩；连接平行的类层次 总结： 工厂模式中，核心的工厂类不再负责所有产品的创建，而是将具体的创建工作交给子类去做； 增加新产品类时无需修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性； 增加新产品时需要增加新的工厂，导致系统类的个数成对增加，一定程度上增加了系统的复杂性 抽象工厂模式： 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类； 应用于系统独立于其产品创建、组合和表示时； 当系统提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的产品时 效果： 隔离了具体类的生成，使得客户并不需要知道什么被创建，更换一个具体工厂就变得相对容易； 改变具体工厂的实例，就可以在某种程度上改变软件系统的行为； 高内聚低耦合 单例模式（对象创建型模式）：保证一个类仅有一个实例，提供一个全局访问点 效果： 严格控制客户怎样及何时访问它； 对全局变量的一种改进，避免污染名空间； 允许对操作和表示的精化 生成器模式（对象创建型模式）： 逐步构造对象，使得对象的创建更具弹性； 将一个包含多个组件对象的创建分成若干个步骤，并将这些步骤封装在Builder接口中 效果： 使产品的内部表象可以独立变化； 每一个builder相对独立，与其他builder无关； 可对构造过程更加精细控制； 将构建代码和表示代码分开 第五章 架构模式 多视图方法是软件架构归档的方法，更是指导我们进行架构设计的思维方法 软件架构视图：对于从某一视角或某一点上看到的系统所做的简化描述，描述中涵盖了系统的某一特定方面，而省略了于此方面无关的实体 4+1视图： 逻辑架构：关注功能，着重考虑功能需求 开发架构：关注程序包，着重考虑开发期质量属性 运行架构：关注进程、线程、对象等运行时概念及相关的并发同步通信等问题，着重考虑运行期质量属性 物理架构：关注软件系统最终如何安装或部署到物理机器 数据架构：关注持久化数据的存储方案 逻辑视图：关注用户可见的功能，还包括为实现用户功能而必须提供的辅助功能模块 开发视图：关注程序包，不仅包括编写的源程序，还有可以直接使用的第三方SDK和现成框架、类库、中间件 运行视图：关注运行时单元的交互问题 物理视图：重视目标程序的静态位置问题 场景视图：可理解性 分层架构模式： 系统将划分为一个层次结构； 各层之间的关系是客户/服务器； 每一层都具有高度内聚性； 有助于将复杂系统划分成独立模块； 每层都向上层提供服务，同时又利用了下层的逻辑功能 上层通过下层提供的接口来使用下层的功能 优点：减少依赖程度、支持扩展、支持重用 缺点：层次划分不易、不一定能够层次化、系统性能下降、难以调试 管道过滤器架构模式： 过滤器读取数据，加工转换，变成输出数据； 过滤器间通过管道连接； 每个过滤器是独立的实体； 管道传输和缓存数据 优点：简单性；重用性；系统易维护和扩展；并发性 缺点：过滤器对输入数据批量转换；不适合设计交互式应用系统；兼容性弱；降低系统效率 插件架构模式：扩展点用接口表示，插件用于实现这些接口并安装；应用在没有添加扩展时也能正常使用 优点： 每个插件有自己的职责范围； 便于第三方扩展； 保持系统的精简； 支持多版本同时运行； 插件的独立测试 缺点： 初始过程消耗高； 执行过程中管理开销不断提高； 插件和接口有依赖关系 中介模式（分布式系统架构模式）：服务器组件提供一个或多个服务；客户组件需要服务器组件的一个或多个服务 优点：客户无需知道服务器的物理地址；通过服务器的逻辑名称实现了隐藏 缺点：容错性差；间接调用增加了调用的通信开销；中介可能形成拼接 对比： 中介者模式同事通过mediator通信，处在同一系统。发送和接受1：n关系； 中介模式负责分布式系统中确定接受组件位置，发送和接受1：1 SOA架构模式： 把一个业务流程直接构建为一个计算机系统； 应用场景被分配给设计的组件，易于修改； 一个应用场景的目标就是实现一个服务； 一个业务流程会使用这个服务 优点： 根据业务流程构成服务组件； 分解服务组件和基本服务组件，减小系统复杂性； 可复用； 接口不变，服务的实现可动态转换 缺点： 过于细分服务组成复杂的结构； 多个层次通信增加额外开销 MVC模式： 模型（核心功能）封装系统数据和对数据的加工； 视图把数据展示给用户，含有模型要展示的数据； 控制器负责接收用户的输入，对输入的内容进行解释 优点： 模型类和用户界面分别设计； 修改界面无需更改模型；模型单独测试； 同一应用设计不同用户界面 缺点： 经常更新影响系统性能； 细分多个类增加实现开销]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>复习提纲</tag>
        <tag>软件设计与体系结构</tag>
      </tags>
  </entry>
</search>
