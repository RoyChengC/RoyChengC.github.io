<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roy Cheng 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://roychengc.github.io/"/>
  <updated>2019-04-21T15:16:59.844Z</updated>
  <id>https://roychengc.github.io/</id>
  
  <author>
    <name>Roy Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 49 Group Anagrams</title>
    <link href="https://roychengc.github.io/2019/04/21/leetcode-49-Group-Anagrams/"/>
    <id>https://roychengc.github.io/2019/04/21/leetcode-49-Group-Anagrams/</id>
    <published>2019-04-21T15:10:58.000Z</published>
    <updated>2019-04-21T15:16:59.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. Group Anagrams</a></h4><p>Given an array of strings, group anagrams together.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>All inputs will be in lowercase.</li><li>The order of your output does not matter.</li></ul><p>给你一组字符串，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>分析题意，如果将错位词的字符顺序重新排列，会得到同样的结果。那么可以考虑使用一个 map，map 的 key 代表了重新排列顺序后的错位词，将所有错位词都保存到一个字符串数组中，建立key和字符串数组之间的一一对应关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; ++i) &#123;</span><br><span class="line">            String s = strs[i];</span><br><span class="line">            <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">            Arrays.sort(ch);</span><br><span class="line">            s = <span class="keyword">new</span> String(ch);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (map.get(s) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.get(s).add(strs[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                temp.add(strs[i]);</span><br><span class="line">                map.put(s, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;49-Group-Anagrams&quot;&gt;&lt;a href=&quot;#49-Group-Anagrams&quot; class=&quot;headerlink&quot; title=&quot;49. Group Anagrams&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/p
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="哈希表" scheme="https://roychengc.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记: 接口和抽象类有什么区别</title>
    <link href="https://roychengc.github.io/2019/04/21/Java%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://roychengc.github.io/2019/04/21/Java笔记-接口和抽象类有什么区别/</id>
    <published>2019-04-21T14:12:15.000Z</published>
    <updated>2019-04-21T14:31:07.925Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口和抽象类有什么区别"><a href="#接口和抽象类有什么区别" class="headerlink" title="接口和抽象类有什么区别"></a>接口和抽象类有什么区别</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>接口和抽象类是 Java 面向对象设计的两个基础机制。</p><p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以使 API 定义和实现分离的目的。另外，接口不能实例化，不能包含任何非常量成员，同时没有非静态方法实现，也就是受要么是抽象方法，要么是静态方法。</p><p>抽象类同样不能实例化，用 abstract 关键字修饰，其目的主要是通过继承的方式达到代码重用。除了不能实例化外，形式上和一般的 Java 类并没有太大区别，它可以包含一个或多个抽象方法，也可以没有抽象方法。</p><p>Java 类实现接口使用 implements 关键词，继承抽象类使用 extends关键词。</p><p>Java 不支持多继承，但是可以实现多个接口，因为接口是抽象方法的集合，所以这是声明性的，但不能通过扩展多个抽象类来重用逻辑。</p><p>为接口添加任何抽象方法，相应的所有实现了这个接口的类，也必须实现新增方法；对于抽象类，添加非抽象方法，其子类只会享受到能力扩展，而不用担心编译出问题。</p><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p><strong>1.面向对象设计</strong></p><p>面向对象的基本要素：封装、继承、多态。</p><p>封装是为了隐藏事物内部的实现细节，从而提高安全性并简化编程。封装避免外部调用者接触到内部的细节。</p><p>继承是代码复用的基础。继承可以看作是非常高耦合的一种关系，父类代码修改后子类的行为会发生变动。在实践中过度滥用继承可能会起到反效果。</p><p>多态，大家可能会联想到重写（override）和重载（overload）、向上转型。重写是父类和子类中相同名字和参数的方法，实现过程不同；重载是相同名字的方法，但是参数不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入参数不同，意味着方法签名不同，重载的体现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(List&lt;String&gt; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return 类型不一样，编译不能通过</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;接口和抽象类有什么区别&quot;&gt;&lt;a href=&quot;#接口和抽象类有什么区别&quot; class=&quot;headerlink&quot; title=&quot;接口和抽象类有什么区别&quot;&gt;&lt;/a&gt;接口和抽象类有什么区别&lt;/h3&gt;&lt;h4 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java笔记" scheme="https://roychengc.github.io/categories/Java%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>杂记: 常见的HTTP Method</title>
    <link href="https://roychengc.github.io/2019/04/20/%E6%9D%82%E8%AE%B0-%E5%B8%B8%E8%A7%81%E7%9A%84HTTP-Method/"/>
    <id>https://roychengc.github.io/2019/04/20/杂记-常见的HTTP-Method/</id>
    <published>2019-04-20T15:17:56.000Z</published>
    <updated>2019-04-20T15:29:30.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的HTTP-Method"><a href="#常见的HTTP-Method" class="headerlink" title="常见的HTTP Method"></a>常见的HTTP Method</h1><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>通常用于请求服务器发送某个资源。</p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>向服务器写入文档。</p><p>PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，如果那个 URL 已经存在，就用这个主体来替代它。</p><p>和 POST 方法一样，PUT 方法改变了资源的状态，所以是非安全的。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST 方法起初是用来向服务器输入数据的。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送到服务器，然后由服务器将其发送到它要去的地方。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。和 POST 方法一样，DELETE 方法也改变了资源的状态，所以是非安全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常见的HTTP-Method&quot;&gt;&lt;a href=&quot;#常见的HTTP-Method&quot; class=&quot;headerlink&quot; title=&quot;常见的HTTP Method&quot;&gt;&lt;/a&gt;常见的HTTP Method&lt;/h1&gt;&lt;h4 id=&quot;GET&quot;&gt;&lt;a href=&quot;#GE
      
    
    </summary>
    
      <category term="杂记" scheme="https://roychengc.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="HTTP" scheme="https://roychengc.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 31 Next Permutation</title>
    <link href="https://roychengc.github.io/2019/04/19/leetcode-31-Next-Permutation/"/>
    <id>https://roychengc.github.io/2019/04/19/leetcode-31-Next-Permutation/</id>
    <published>2019-04-19T13:16:43.000Z</published>
    <updated>2019-04-19T13:22:57.164Z</updated>
    
    <content type="html"><![CDATA[<h4 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. Next Permutation</a></h4><p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be <strong>in-place</strong> and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure><p>求一个数组的下一个更大的排列，如果不存在更大的，重新排列成最小的排列。只允许常数额外空间。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从数组后面往前遍历，找到第一个比前面一个小的数，记下该数的下标 pos，再从该下标从前往后遍历，找到刚好大于这个数的数，并与它交换。最后把下标为 pos 后的数反转。</p><p><img src="https://leetcode-cn.com/media/original_images/31/31_Next_Permutation.gif" alt="Next Permutation"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 要交换的数距离末尾2</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == nums.length &amp;&amp; nums[i] &gt; nums[pos]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[pos];</span><br><span class="line">                nums[pos] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt;= nums[pos]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i - <span class="number">1</span>];</span><br><span class="line">                nums[i - <span class="number">1</span>] = nums[pos];</span><br><span class="line">                nums[pos] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">int</span> low = pos + <span class="number">1</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[low];</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            nums[high] = temp;</span><br><span class="line">            low++;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;31-Next-Permutation&quot;&gt;&lt;a href=&quot;#31-Next-Permutation&quot; class=&quot;headerlink&quot; title=&quot;31. Next Permutation&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Java笔记: Java提供了哪些IO方式</title>
    <link href="https://roychengc.github.io/2019/04/17/Java%E7%AC%94%E8%AE%B0-Java%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9BIO%E6%96%B9%E5%BC%8F/"/>
    <id>https://roychengc.github.io/2019/04/17/Java笔记-Java提供了哪些IO方式/</id>
    <published>2019-04-17T13:50:56.000Z</published>
    <updated>2019-04-17T15:08:39.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-提供了哪些-IO-方式"><a href="#Java-提供了哪些-IO-方式" class="headerlink" title="Java 提供了哪些 IO 方式"></a>Java 提供了哪些 IO 方式</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>首先，我们有传统的基于流模型实现的 java.io 包，提供了如 File抽象、输入输出流等。交互方式是同步、阻塞的方式，即在读取输入流或写入输出流时，在读写动作完成前，线程会一直阻塞在那里。java.io 包使用比较简单直观，缺点是 IO 效率和扩展性有所局限，影响了一定的性能。</p><p>有些时候，人们也把 java.net 中提供的部分网络 API，如 Socket、ServerSocket、HttpURLConnection 也归类为同步阻塞 IO 类库，因为网络通信也属于 IO 行为。</p><p>另外，Java 1.4 中引入了 NIO 框架（java.nio 包），它提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><p>在 Java 7 中，NIO 有了进一步改进，它引入了异步非阻塞 IO 方式。异步 IO 操作基于事件和回调机制，可以理解为操作会直接返回，而不会阻塞，当后台处理完成，操作系统会通知相应线程继续工作。</p><p>.</p><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p><strong>1.一些基本概念</strong></p><p>同步和异步：同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务在当前调用返回后才继续工作；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调机制来实现任务间的次序关系。</p><p>阻塞与非阻塞：进行阻塞操作时，当前线程会处于阻塞状态，不能进行其他任务，只有当条件就绪后才能继续，比如 ServerSocket 新连接建立完成，或数据读取、写入操作完成；而非阻塞则不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</p><p>同步和阻塞不一定是低效的，我们需要根据不同场合分析效率。</p><p><strong>2. java.io 相关知识</strong></p><p>IO 的一些基本知识：</p><ul><li>IO 不仅仅是对文件的操作，在网络编程中如 Socket 通信，都是典型的 IO 操作目标</li><li>输入流和输出流是用于读取或写入字节的</li><li>Reader / Writer 则是用于操作字符，增加了字符编码和解码等功能，应用于从文件中读取或把信息写入文件</li><li>BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，可以批量操作数据，但是在使用过程中一定要 flush</li></ul><p>下面是一个简化的 IO 工具类图</p><p><img src="https://static001.geekbang.org/resource/image/43/8b/4338e26731db0df390896ab305506d8b.png" alt="img"></p><p><strong>3. Java NIO 概述</strong></p><p>首先了解一下 NIO 的主要组成部分：</p><ul><li>Buffer，一个高效的数据容器，所有原始数据类型都有相应的 Buffer 实现</li><li>Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。Channel 与 File 或 Socket 相比是更加操作系统底层的抽象，这也使得 NIO 得以充分利用操作系统底层机制，实现特定场景的性能优化，例如 DMA 等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然</li><li>Selector，是 NIO 实现多路复用的基础，它可以检测到注册在 Selector 上的多个 Channel 中是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理</li><li>Chartset，提供 Unicode 字符串定义，NIO 也提供了相应的编码解码器</li></ul><p><strong>4. NIO能解决什么问题</strong></p><p>假如我们需要实现一个服务器应用，只需要能够同时服务多个客户端请求即可。使用 java.io 和 java.net 中的同步阻塞式 API 可以简单实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  serverSocket.getLocalPort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler(socket);</span><br><span class="line">                requestHandler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DemoServer server = <span class="keyword">new</span> DemoServer();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">try</span> (Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), server.getPort())) &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span>                   InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 简化实现，不做读取，直接发送字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    RequestHandler(Socket socket) &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());) &#123;</span><br><span class="line">            out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现要点是：</p><ul><li>服务端启动 ServerSocket，端口 0 表示自动绑定一个空闲端口</li><li>调用 accept 方法，阻塞等待客户端连接</li><li>利用 Socket 模拟了一个简单的客户端，只进行连接、读取、打印</li><li>连接建立后，启动一个单线程负责回复客户端的请求</li></ul><p>Java 语言目前在线程的实现是比较繁琐复杂的，启动或销毁一个线程是具有明显开销的，每一个线程需要占用很明显的内存，所以每一个 Client 启动一个线程好像有点浪费。</p><p>我们可以引入线程池机制避免浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">0</span>);</span><br><span class="line">executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler(socket);</span><br><span class="line">    executor.execute(requestHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个固定大小的线程池负责管理工作线程，避免频繁创建、销毁线程的开销。这种工作方式可以参考下图来理解。</p><p><img src="https://static001.geekbang.org/resource/image/da/29/da7e1ecfd3c3ee0263b8892342dbc629.png" alt="img"></p><p>如果连接数不多的话，这种解决方法还是不错的。但是连接数一大，线程的上下文切换会在高并发时变得很明显，这是同步阻塞方式的低扩展性的劣势。</p><p>而NIO 引入的多路复用机制，提供了另外一种思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Selector selector = Selector.open();</span><br><span class="line">             ServerSocketChannel serverSocket = ServerSocketChannel.open();) &#123;<span class="comment">// 创建 Selector 和 Channel</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), <span class="number">8888</span>));</span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到 Selector，并说明关注点</span></span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();<span class="comment">// 阻塞等待就绪的 Channel，这是关键点之一</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                   <span class="comment">// 生产系统中一般会额外进行就绪状态检查</span></span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">(ServerSocketChannel server)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SocketChannel client = server.accept();) &#123;          client.write(Charset.defaultCharset().encode(<span class="string">"Hello world!"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 省略了与前面类似的 main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析一下主要步骤：</p><ul><li>首先通过 Selector.open() 创建一个 Selector，作为类似调度员的角色</li><li>然后创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员它关注的是新的连接请求</li><li>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒</li><li>在 sayHelloWorld 方法中，通过 SocketChannel 和 Buffer 进行数据操作</li></ul><p>我们可以发现，在前面两个样例中，IO 都是同步阻塞模式，所以需要多线程实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，高效地定位就绪的 Channel，来决定做什么。下图对这种思路进行了说明。</p><p><img src="https://static001.geekbang.org/resource/image/ad/a2/ad3b4a49f4c1bff67124563abc50a0a2.png" alt="img"></p><p>在 Java 7 引入的 NIO 2 中，又添加了一种异步的 IO 模式，利用事件和回调，处理 Accept、Read 等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel serverSock =        AsynchronousServerSocketChannel.open().bind(sockAddr);</span><br><span class="line">serverSock.accept(serverSock, <span class="keyword">new</span> CompletionHandler&lt;&gt;() &#123; <span class="comment">// 为异步操作指定 CompletionHandler 回调函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel sockChannel, AsynchronousServerSocketChannel serverSock)</span> </span>&#123;</span><br><span class="line">        serverSock.accept(serverSock, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 另外一个 write（sock，CompletionHandler&#123;&#125;）</span></span><br><span class="line">        sayHelloWorld(sockChannel, Charset.defaultCharset().encode</span><br><span class="line">                (<span class="string">"Hello World!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 省略其他路径处理方法...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里基本抽象很类似，AsynchronousServerSocketChannel 对应于上面例子中的 ServerSocketChannel；AsynchronousSocketChannel 对应 SocketChannel。</p><p>业务逻辑的关键在于，通过指定 CompletionHandler 回调接口，在 accept / read / write 等关键节点，通过事件机制调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java-提供了哪些-IO-方式&quot;&gt;&lt;a href=&quot;#Java-提供了哪些-IO-方式&quot; class=&quot;headerlink&quot; title=&quot;Java 提供了哪些 IO 方式&quot;&gt;&lt;/a&gt;Java 提供了哪些 IO 方式&lt;/h3&gt;&lt;h4 id=&quot;基本知识&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Java笔记" scheme="https://roychengc.github.io/categories/Java%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java笔记: 如何保证容器是线程安全的</title>
    <link href="https://roychengc.github.io/2019/04/16/Java%E7%AC%94%E8%AE%B0-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%B9%E5%99%A8%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84/"/>
    <id>https://roychengc.github.io/2019/04/16/Java笔记-如何保证容器是线程安全的/</id>
    <published>2019-04-16T13:12:25.000Z</published>
    <updated>2019-04-16T13:59:18.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何保证容器是线程安全的"><a href="#如何保证容器是线程安全的" class="headerlink" title="如何保证容器是线程安全的"></a>如何保证容器是线程安全的</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>Java 提供了不同层面的线程安全支持。在传统集合中，除了 Hashtable 等同步容器，还提供了同步包装器，我们可以调用 Collections 工具类提供的包装方法，来获取一个同步的包装容器，但是它们都是非常粗的同步方式，性能较低下。</p><p>更常见的选择是使用线程安全容器类，它提供了：</p><ul><li>各种并发容器，如 ConcurrentHashMap、CopyOnWriteArrayList</li><li>各种线程安全队列，如 ArrayBlockingQueue、SynchronousQueue</li><li>各种有序容器的线程安全版本等</li></ul><p>总的来说，保证线程安全的方式有简单的 synchronize 方式，还有更加精细的 ConcurrentHashMap 等并发实现等。不过，并发包内提供的容器远优于简单的同步实现。</p><p>.</p><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p><strong>1.为什么需要 ConcurrentHashMap</strong></p><p>因为 Hashtable 比较低效，它的实现基本只是将 put、get 等方法加上 synchronized。这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，因此效率低下。</p><p><strong>2.ConcurrentHashMap 分析</strong></p><p>ConcurrentHashMap 的设计实现一直在演化，早期的 ConcurrentHashMap，其实现是基于：</p><ul><li>分离锁，即将内部进行分段，里面则是 HashEntry 数组，和 HashMap 类似，哈希相同的数据也是以链表形式存储</li><li>HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，直接完成部分操作，以最优化性能</li></ul><p>下面是早期 ConcurrentHashMap 内部结构的示意图，核心是利用分段设计，在进行并发操作的时候，只需要锁定相应段，这样就有效避免了类似 Hashtable 整体同步的问题，大大提高了性能。</p><p><img src="https://static001.geekbang.org/resource/image/d4/d9/d45bcf9a34da2ef1ef335532b0198bd9.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何保证容器是线程安全的&quot;&gt;&lt;a href=&quot;#如何保证容器是线程安全的&quot; class=&quot;headerlink&quot; title=&quot;如何保证容器是线程安全的&quot;&gt;&lt;/a&gt;如何保证容器是线程安全的&lt;/h3&gt;&lt;h4 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; cla
      
    
    </summary>
    
      <category term="Java笔记" scheme="https://roychengc.github.io/categories/Java%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 46 Permutations</title>
    <link href="https://roychengc.github.io/2019/04/16/leetcode-46-Permutations/"/>
    <id>https://roychengc.github.io/2019/04/16/leetcode-46-Permutations/</id>
    <published>2019-04-16T12:56:17.000Z</published>
    <updated>2019-04-16T13:01:01.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations</a></h4><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给你一个没有重复数字的数组，返回所有可能的排列。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用递归 + 回溯的方法，每次递归从数组 nums 里面取一个数字添加到一个解 list 中，并把这个数字从数组里删除。回溯时把第 n 次递归删除的数添加进数组 nums 里，再把 list 中最后一个元素删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums.get(i);</span><br><span class="line">            nums.remove(i);</span><br><span class="line">            list.add(temp);</span><br><span class="line">            generate(result, list, nums);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            nums.add(i, temp); <span class="comment">// 添加回删除的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; n = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            n.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        generate(result, list, n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;46-Permutations&quot;&gt;&lt;a href=&quot;#46-Permutations&quot; class=&quot;headerlink&quot; title=&quot;46. Permutations&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="递归" scheme="https://roychengc.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="https://roychengc.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 47 Permutations II</title>
    <link href="https://roychengc.github.io/2019/04/16/leetcode-47-Permutations-II/"/>
    <id>https://roychengc.github.io/2019/04/16/leetcode-47-Permutations-II/</id>
    <published>2019-04-16T12:54:24.000Z</published>
    <updated>2019-04-16T13:05:44.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. Permutations II</a></h4><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给你一个可能存在重复数字的数组，求出所有可能的排列。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题与<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations</a>解法相似，区别在于这题的数组中可能存在重复数字，因此我们要考虑去重的问题。我们把题目所给的数组先从小到大排序，然后在执行递归函数之前判断 nums[i] 与 nums[i - 1] 是否相等，如果相等，continue 循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums.get(i) == nums.get(i - <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums.get(i);</span><br><span class="line">            nums.remove(i);</span><br><span class="line">            list.add(temp);</span><br><span class="line">            generate(result, list, nums);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            nums.add(i, temp); <span class="comment">// 添加回删除的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        generate(result, temp, list);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;47-Permutations-II&quot;&gt;&lt;a href=&quot;#47-Permutations-II&quot; class=&quot;headerlink&quot; title=&quot;47. Permutations II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.co
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="递归" scheme="https://roychengc.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="https://roychengc.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 345 Reverse Vowels of a String</title>
    <link href="https://roychengc.github.io/2019/04/13/leetcode-345-Reverse-Vowels-of-a-String/"/>
    <id>https://roychengc.github.io/2019/04/13/leetcode-345-Reverse-Vowels-of-a-String/</id>
    <published>2019-04-13T13:54:04.000Z</published>
    <updated>2019-04-13T14:02:03.453Z</updated>
    
    <content type="html"><![CDATA[<h4 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. Reverse Vowels of a String</a></h4><p>Write a function that takes a string as input and reverse only the vowels of a string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;hello&quot;</span><br><span class="line">Output: &quot;holle&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;leetcode&quot;</span><br><span class="line">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p><p>反转一个字符串中的元音字母。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用双指针法，创建两个指针 low 和 high 分别指向 0 和 s.length() - 1，然后创建一个新的字符数组 result，通过遍历，如果 s[low] 和 s[high] 都是元音，result[low++] = s[high]，result[high- -] = s[low]；如果 s[low] 或 s[high] 不是元音，则 result[low++] = s[low]，result[high- -] = s[high]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">'a'</span> || c == <span class="string">'A'</span> || c == <span class="string">'e'</span> || c == <span class="string">'E'</span> || c == <span class="string">'i'</span> || c == <span class="string">'I'</span> || c == <span class="string">'o'</span> || c == <span class="string">'O'</span> || c == <span class="string">'u'</span> || c == <span class="string">'U'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">char</span> a = s.charAt(low);</span><br><span class="line">            <span class="keyword">char</span> b = s.charAt(high);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!isVowel(a)) result[low++] = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!isVowel(b)) result[high--] = b;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[low++] = b;</span><br><span class="line">                result[high--] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;345-Reverse-Vowels-of-a-String&quot;&gt;&lt;a href=&quot;#345-Reverse-Vowels-of-a-String&quot; class=&quot;headerlink&quot; title=&quot;345. Reverse Vowels of a String&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="双指针" scheme="https://roychengc.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 215 Kth Largest Element in an Array</title>
    <link href="https://roychengc.github.io/2019/04/13/leetcode-215-Kth-Largest-Element-in-an-Array/"/>
    <id>https://roychengc.github.io/2019/04/13/leetcode-215-Kth-Largest-Element-in-an-Array/</id>
    <published>2019-04-13T13:32:48.000Z</published>
    <updated>2019-04-13T13:36:04.596Z</updated>
    
    <content type="html"><![CDATA[<h4 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. Kth Largest Element in an Array</a></h4><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><p>找到一个未排序的数组中第 k 大的元素。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以使用堆排序，维护一个优先级队列，遍历所有元素时把元素往队列里放，保持这个队列的大小不大于 k，最后返回队列的第一个元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            pq.add(n);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;215-Kth-Largest-Element-in-an-Array&quot;&gt;&lt;a href=&quot;#215-Kth-Largest-Element-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;215. Kth Largest Eleme
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="排序" scheme="https://roychengc.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 34 Find First and Last Position of Element in Sorted Array</title>
    <link href="https://roychengc.github.io/2019/04/13/leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/"/>
    <id>https://roychengc.github.io/2019/04/13/leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</id>
    <published>2019-04-13T13:19:28.000Z</published>
    <updated>2019-04-13T13:23:25.443Z</updated>
    
    <content type="html"><![CDATA[<h4 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. Find First and Last Position of Element in Sorted Array</a></h4><p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p>If the target is not found in the array, return <code>[-1, -1]</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p>给你一个排好序的数组和一个目标值，在数组中找到第一个等于目标值和最后一个等于目标值的元素的下标，如果没有找到目标值，返回 [-1，-1]。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用二分查找法找到目标值所在的下标，然后根据这个下标往左右扩展即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> find = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                find = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        low = find;</span><br><span class="line">        high = find;</span><br><span class="line">        <span class="keyword">while</span> (nums[low] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (low &gt; <span class="number">0</span> &amp;&amp; nums[low - <span class="number">1</span>] == target) &#123;</span><br><span class="line">                low -= <span class="number">1</span>;</span><br><span class="line">                result[<span class="number">0</span>] = low;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[<span class="number">0</span>] = low;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nums[high] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (high &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[high + <span class="number">1</span>] == target) &#123;</span><br><span class="line">                high += <span class="number">1</span>;</span><br><span class="line">                result[<span class="number">1</span>] = high;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[<span class="number">1</span>] = high;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;34-Find-First-and-Last-Position-of-Element-in-Sorted-Array&quot;&gt;&lt;a href=&quot;#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array&quot; cl
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="二分查找" scheme="https://roychengc.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 633 Sum of Square Numbers</title>
    <link href="https://roychengc.github.io/2019/04/13/leetcode-633-Sum-of-Square-Numbers/"/>
    <id>https://roychengc.github.io/2019/04/13/leetcode-633-Sum-of-Square-Numbers/</id>
    <published>2019-04-13T09:33:01.000Z</published>
    <updated>2019-04-13T09:39:31.704Z</updated>
    
    <content type="html"><![CDATA[<h4 id="633-Sum-of-Square-Numbers"><a href="#633-Sum-of-Square-Numbers" class="headerlink" title="633. Sum of Square Numbers"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">633. Sum of Square Numbers</a></h4><p>Given a non-negative integer <code>c</code>, your task is to decide whether there’re two integers <code>a</code> and <code>b</code>such that a^2 + b^2 = c.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p>给你一个非负整数 c，判断是否存在两个整数a、b，使得a^2+b^2 = c</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用双指针法。首先我们可以确定取数的范围 0~根号c，使用两个指针分别指向 0 和根号c，然后从这个范围进行遍历。</p><p>注意有一个例子是 4，这个样例应该返回 true，因为 0 + 2*2 = 4，可以找到两个整数 0 和 2，因此取数的最小值是 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = (<span class="keyword">int</span>) Math.sqrt(c);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = low * low + high * high;</span><br><span class="line">            <span class="keyword">if</span> (sum == c) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; c) low++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; c) high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;633-Sum-of-Square-Numbers&quot;&gt;&lt;a href=&quot;#633-Sum-of-Square-Numbers&quot; class=&quot;headerlink&quot; title=&quot;633. Sum of Square Numbers&quot;&gt;&lt;/a&gt;&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="双指针" scheme="https://roychengc.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记: Hashtable、HashMap、TreeMap 有什么不同</title>
    <link href="https://roychengc.github.io/2019/04/10/Java%E7%AC%94%E8%AE%B0-HashTable%E3%80%81HashMap%E3%80%81TreeMap-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/"/>
    <id>https://roychengc.github.io/2019/04/10/Java笔记-HashTable、HashMap、TreeMap-有什么不同/</id>
    <published>2019-04-10T13:38:49.000Z</published>
    <updated>2019-04-11T11:05:10.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hashtable、HashMap、TreeMap-有什么不同"><a href="#Hashtable、HashMap、TreeMap-有什么不同" class="headerlink" title="Hashtable、HashMap、TreeMap 有什么不同"></a>Hashtable、HashMap、TreeMap 有什么不同</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>Hashtable 是早期 Java 提供的一个哈希表，它是同步的，并且不支持 null 键和值。现在很少使用它，因为它存在同步产生的开销。</p><p>HashMap 应用更加广泛，功能上与 Hashtable 基本一样，区别在于 HashMap 不是同步的，并且支持 null 的键和值。通常 HashMap 进行 put 或 get 操作可以达到常数时间的性能，所以大部分情况使用 HashMap 比较多，如实现一个用户 ID 和用户信息对应的运行时存储结构。</p><p>TreeMap 是基于红黑树的一种提供顺序访问的 Map。和 HashMap 相比，它的 put、get 等操作都是 O(log(n)) 的时间复杂度。访问顺序由指定的 Comparator 决定或根据键的自然顺序决定。</p><p>.</p><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p><strong>1.Map整体结构</strong></p><p>Map 虽然被包括在 Java 集合框架中，但它本身并不是狭义上的集合类型，下面是一个简单类图。</p><p><img src="https://static001.geekbang.org/resource/image/26/7c/266cfaab2573c9777b1157816784727c.png" alt="img"></p><p>可以看出 Hashtable 扩展了 Dictionary 类，类结构上与 HashMap 有明显不同。</p><p>HashMap 和其他一些 Map 都是扩展了 AbstractMap，里面包含了通用方法抽象。</p><p>我们使用 Map 一般都是访问、插入、删除操作，对顺序没有特别要求，因此 HashMap 是最好的选择。</p><p>如果对顺序有要求，可以使用 LinkedHashMap 和 TreeMap。</p><p>LinkedHashMap 通常提供的是符合插入顺序，它是为键值对维护一个双向链表。</p><p>对于 TreeMap，它的整体顺序是由键的顺序关系决定的。</p><p>.</p><p><strong>2.HashMap 内部结构</strong></p><p>HashMap 可以看作是一个数组（Node&lt;K, V&gt; [] table）和链表结合组成的复合结构，数组被分为一个个桶，通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，下面是结构图。如果链表大小超过阈值（TREEIFY_THRESHOLD，8），图中的链表就会被改造成树形结构。</p><p><img src="https://static001.geekbang.org/resource/image/1f/56/1f72306a9d8719c66790b56ef7977c56.png" alt="img"></p><p>.</p><p><strong>3.解决哈希冲突的方法</strong></p><p>开放定址法：</p><p>当关键字 key 的哈希地址 p = H（key）出现冲突时，以 p 为基础，产生另一个哈希地址 p1，如果 p1 任然冲突，再以 p 为基础，产生另一个哈希地址 p2，直到找出一个不冲突的哈希地址 pi，将相应元素存入其中。</p><p>再哈希法：</p><p>同时构造多个不同的哈希函数 Hi = RH1（key） i = 1，2，… ，k</p><p>当哈希地址 Hi = RH1（key）发生冲突时，再计算 Hi = RH2（key），直到不产生冲突。</p><p>链地址法：</p><p>将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因此查找、插入、删除主要在同义词链中进行。链地址法适用于经常插入和删除的情况。</p><p>建立公共溢出区：</p><p>将哈希表分为基本表和溢出表两个部分，凡是和基本表发生冲突的元素，一律放入溢出表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hashtable、HashMap、TreeMap-有什么不同&quot;&gt;&lt;a href=&quot;#Hashtable、HashMap、TreeMap-有什么不同&quot; class=&quot;headerlink&quot; title=&quot;Hashtable、HashMap、TreeMap 有什么不
      
    
    </summary>
    
      <category term="Java笔记" scheme="https://roychengc.github.io/categories/Java%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 41 First Missing Positive</title>
    <link href="https://roychengc.github.io/2019/04/10/leetcode-41-First-Missing-Positive/"/>
    <id>https://roychengc.github.io/2019/04/10/leetcode-41-First-Missing-Positive/</id>
    <published>2019-04-10T13:24:23.000Z</published>
    <updated>2019-04-10T13:36:12.724Z</updated>
    
    <content type="html"><![CDATA[<h4 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. First Missing Positive</a></h4><p>Given an unsorted integer array, find the smallest missing positive integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p><p>给定一个乱序的数组，找到缺失的最小正整数。要求时间复杂度为O(n)，常数的额外空间。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先遍历一遍数组，把正整数加进一个 list 中，并找到最大值。之后进行一次遍历，从 1 到最大值与 list 中的元素比较，如果有一个没有对应上，返回这个值，否则返回最大值加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; maxx) maxx = nums[i];</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxx; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!list.contains(i)) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) result = maxx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>以下出自: <a href="http://www.cnblogs.com/AnnieKim/" target="_blank" rel="noopener">http://www.cnblogs.com/AnnieKim/</a></p><p>交换数组元素，使得数组中第i位存放数值(i+1)。最后遍历数组，寻找第一个不符合此要求的元素，返回其下标。</p><p><img src="https://images0.cnblogs.com/blog/300640/201304/21220310-d1b03fc59dd24e82b6db34a2cae12111.jpg" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] != (i+<span class="number">1</span>) &amp;&amp; A[i] &gt;= <span class="number">1</span> &amp;&amp; A[i] &lt;= n &amp;&amp; A[A[i]<span class="number">-1</span>] != A[i])</span><br><span class="line">                swap(A[i], A[A[i]<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (A[i] != (i+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;41-First-Missing-Positive&quot;&gt;&lt;a href=&quot;#41-First-Missing-Positive&quot; class=&quot;headerlink&quot; title=&quot;41. First Missing Positive&quot;&gt;&lt;/a&gt;&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="数组" scheme="https://roychengc.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 40 Combination Sum II</title>
    <link href="https://roychengc.github.io/2019/04/10/leetcode-40-Combination-Sum-II/"/>
    <id>https://roychengc.github.io/2019/04/10/leetcode-40-Combination-Sum-II/</id>
    <published>2019-04-10T12:06:47.000Z</published>
    <updated>2019-04-10T12:17:21.401Z</updated>
    
    <content type="html"><![CDATA[<h4 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. Combination Sum II</a></h4><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p><p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong></p><ul><li>All numbers (including <code>target</code>) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>大致和第39题（<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum</a>）一样，唯一区别是该题每个数字只能取一次。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>同样采用递归加回溯，只需要在递归调用 generate 的时候把 i 改成 i + 1。但是，如果 candidates 中有重复的元素，那么 result 中也会有重复的元素。我们需要在 for 循环遍历时判断当前数字与之前的数字是否相同，相同的话 continue 循环。这样的话，在回溯的时候就不会取 candidates 中重复的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// result为所有解，list为一个解，t为遍历到candidates的第几个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(List&lt;List&lt;Integer&gt; &gt; result, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 每次减去一个candidates[t]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; candidates.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 模拟解</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; t &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            generate(result, list, candidates, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯，删除末尾元素</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt; &gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        generate(result, list, candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;40-Combination-Sum-II&quot;&gt;&lt;a href=&quot;#40-Combination-Sum-II&quot; class=&quot;headerlink&quot; title=&quot;40. Combination Sum II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetc
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="递归" scheme="https://roychengc.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="https://roychengc.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记: Vector、ArrayList、LinkedList 有什么区别</title>
    <link href="https://roychengc.github.io/2019/04/09/Java%E7%AC%94%E8%AE%B0-Vector%E3%80%81ArrayList%E3%80%81LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://roychengc.github.io/2019/04/09/Java笔记-Vector、ArrayList、LinkedList-有什么区别/</id>
    <published>2019-04-09T14:13:41.000Z</published>
    <updated>2019-04-09T14:40:29.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vector、ArrayList、LinkedList-有什么区别"><a href="#Vector、ArrayList、LinkedList-有什么区别" class="headerlink" title="Vector、ArrayList、LinkedList 有什么区别"></a>Vector、ArrayList、LinkedList 有什么区别</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p><strong>Vector</strong> 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全的话，是不推荐使用 Vector 的，因为性能并不好。Vector 内部使用对象数组来保存数据，可以自动增加容量，当数组满时，Vector 会扩容一倍，会创建新的数组，并拷贝原有数据。</p><p><strong>ArrayList</strong> 是应用更加广泛的动态数组，它不是线程安全的，因此性能比 Vector 好很多。ArrayList 也能根据需要调整容量，它在扩容时只增加 50%。</p><p><strong>LinkedList</strong> 是双向链表，它不需要调整容量，也不是线程安全的。</p><p>Vector 和 ArrayList 作为动态数组，内部元素是以数组形式顺序存储的，因此它们适合随机访问的场合。除了在尾部插入和删除元素，它们的性能相对较差。</p><p>LinkedList 进行节点的插入和删除更加高效，但随机访问性能比前两个差。</p><p>.</p><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p><strong>1.集合框架</strong></p><p>下图是一个简要的集合框架类图</p><p><img src="https://static001.geekbang.org/resource/image/67/c7/675536edf1563b11ab7ead0def1215c7.png" alt="img"></p><p>可以看出 Collection 是所有集合的根，通过扩展产生了：</p><ul><li>List，提供方便的访问、插入、删除等操作</li><li>Set，集合，不允许重复的元素</li><li>Queue/Deque，是 Java 提供的标准队列结构的实现，除了集合的基本功能，还支持先进先出行为</li></ul><p>我们需要对各种具体集合实现，至少了解基本特征和典型使用场景，以 Set 为例：</p><ul><li>TreeSet 支持自然顺序访问，但是添加、删除等操作相对低效</li><li>HashSet 利用哈希算法，理想情况下哈希散列正常，则添加、删除等操作是常数时间的，但它不是有序的</li><li>LinkedHashSet，它的内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的功能，同时也保证了常数时间的添加、删除等操作，这些操作的性能略低与 HashSet，因为双向链表需要一定开销</li><li>在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，尽量不要将其背后的 HashMap 容量设置过大。对于LinkedHashSet，由于内部链表提供的便利，遍历性能只和元素多少有关</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vector、ArrayList、LinkedList-有什么区别&quot;&gt;&lt;a href=&quot;#Vector、ArrayList、LinkedList-有什么区别&quot; class=&quot;headerlink&quot; title=&quot;Vector、ArrayList、LinkedLis
      
    
    </summary>
    
      <category term="Java笔记" scheme="https://roychengc.github.io/categories/Java%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 39 Combination Sum</title>
    <link href="https://roychengc.github.io/2019/04/09/leetcode-39-Combination-Sum/"/>
    <id>https://roychengc.github.io/2019/04/09/leetcode-39-Combination-Sum/</id>
    <published>2019-04-09T13:57:24.000Z</published>
    <updated>2019-04-09T14:04:35.951Z</updated>
    
    <content type="html"><![CDATA[<h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum</a></h4><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p><p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including <code>target</code>) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定一组没有重复数字的数组 candidates 和一个目标数字 target，在 candidates 中找出所有可以使数字之和等于 target 的组合。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题可以使用递归加回溯的方法解决。我们引入变量t，代表遍历到第几个 candidates，每次调用递归函数的时候，target 要减去当前的 candidates[i]。当 target 等于 0 时，则找到了一个解，将这个解加入 result 列表中；当 target 小于 0 时，该组解不满足条件，删除列表的最后一个元素，进行回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// result为所有解，list为一个解，t为遍历到candidates的第几个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(List&lt;List&lt;Integer&gt; &gt; result, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(list);</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="comment">//System.out.println(result);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 每次减去一个candidates[t]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; candidates.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 模拟解</span></span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            generate(result, list, candidates, target - candidates[i], i);</span><br><span class="line">            <span class="comment">// 回溯，删除末尾元素</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt; &gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        generate(result, list, candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;39-Combination-Sum&quot;&gt;&lt;a href=&quot;#39-Combination-Sum&quot; class=&quot;headerlink&quot; title=&quot;39. Combination Sum&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.co
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="递归" scheme="https://roychengc.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="https://roychengc.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 38 Count and Say</title>
    <link href="https://roychengc.github.io/2019/04/08/leetcode-38-Count-and-Say/"/>
    <id>https://roychengc.github.io/2019/04/08/leetcode-38-Count-and-Say/</id>
    <published>2019-04-08T14:37:55.000Z</published>
    <updated>2019-04-08T14:43:24.813Z</updated>
    
    <content type="html"><![CDATA[<h4 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">38. Count and Say</a></h4><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p><p>Given an integer <em>n</em> where 1 ≤ <em>n</em> ≤ 30, generate the <em>n</em>th term of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure><p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p><p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出报数序列的第 <em>n</em> 项。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以用递归法求解。报一个数字，只需要知道前面一个的结果，在根据前一个结果计算应该报的数。</p><p>每次递归取前一个的结果，遍历一遍前一个结果，并定义一个 count 计数器，统计重复数字的个数，遍历第 i 次的结果为 count 个 prev[i]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String prev = countAndSay(n - <span class="number">1</span>);</span><br><span class="line">            String result = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            <span class="keyword">int</span> len = prev.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i + <span class="number">1</span> &lt; len &amp;&amp; prev.charAt(i) == prev.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                result += Integer.toString(count) + prev.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;38-Count-and-Say&quot;&gt;&lt;a href=&quot;#38-Count-and-Say&quot; class=&quot;headerlink&quot; title=&quot;38. Count and Say&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/prob
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="递归" scheme="https://roychengc.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 35 Search Insert Position</title>
    <link href="https://roychengc.github.io/2019/04/08/leetcode-35-Search-Insert-Position/"/>
    <id>https://roychengc.github.io/2019/04/08/leetcode-35-Search-Insert-Position/</id>
    <published>2019-04-08T14:06:59.000Z</published>
    <updated>2019-04-08T14:12:56.412Z</updated>
    
    <content type="html"><![CDATA[<h4 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. Search Insert Position</a></h4><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p>给定一个排好序的数组和一个目标值，如果目标值在数组中出现了，返回目标值在数组中的下标，否则返回目标值插入数组后的下标。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以直接遍历一遍数组，若当前数字大于或等于目标值，则返回当前坐标，如果遍历结束了，说明目标值比数组中任何一个数都要大，则返回数组长度n即可。</p><p>我们还可以使用二分查找法优化时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) high = mid;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;35-Search-Insert-Position&quot;&gt;&lt;a href=&quot;#35-Search-Insert-Position&quot; class=&quot;headerlink&quot; title=&quot;35. Search Insert Position&quot;&gt;&lt;/a&gt;&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="二分查找" scheme="https://roychengc.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 167 Two Sum II - Input array is sorted</title>
    <link href="https://roychengc.github.io/2019/04/08/leetcode-167-Two-Sum-II-Input-array-is-sorted/"/>
    <id>https://roychengc.github.io/2019/04/08/leetcode-167-Two-Sum-II-Input-array-is-sorted/</id>
    <published>2019-04-08T13:54:05.000Z</published>
    <updated>2019-04-08T14:02:08.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. Two Sum II - Input array is sorted</a></h4><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><p><strong>Note:</strong></p><ul><li>Your returned answers (both index1 and index2) are not zero-based.</li><li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure><p>给定一个升序排序的整数数组 numbers，在这个数组中找两个数字，使得这两个数字相加等于给定目标数字 target，找到之后返回这两个数字的下标 + 1。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以使用双指针法，用一个指针 low 指向数组头部，另一个指针 high 指向数组尾部。然后在遍历这个数组时，判断 numbers[low] + numbers[high] 是否为 target。当 numbers[low] + numbers[high] &lt; target，说明 numbers[low] 这个数字偏小，需要将 low + 1；当 numbers[low] + numbers[high] &gt; target，说明 numbers[high] 这个数字偏大，需要将 high - 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low != high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; target) high--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) low++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;167-Two-Sum-II-Input-array-is-sorted&quot;&gt;&lt;a href=&quot;#167-Two-Sum-II-Input-array-is-sorted&quot; class=&quot;headerlink&quot; title=&quot;167. Two Sum II - In
      
    
    </summary>
    
      <category term="leetcode" scheme="https://roychengc.github.io/categories/leetcode/"/>
    
    
      <category term="双指针" scheme="https://roychengc.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
